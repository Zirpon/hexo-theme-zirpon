<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <!-- link rel="shortcut icon" href="/img/ironman-draw.png" -->
    <link rel="shortcut icon" href="/img/timg.jpeg">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    <!-- %- css('css/beantech.min.css')% -->
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    
<link rel="stylesheet" href="/css/beantech.css">




    <!--新东西 -->
    
    <!-- wave start -->
    <link rel="stylesheet" href="/css/wave.css" />
    <!-- wave end -->
    

    
    <!-- top start (article top hot config) -->
    <link rel="stylesheet" href="/css/top.css" />
    <!-- top end -->
    

    <a id="rocket" href="#top" class=""></a>

    
      <!-- Search start -->
      <link rel="stylesheet" href="/css/search.css" />
      <!-- Search end -->
    

    
    <!-- ThemeColor start -->
    <link rel="stylesheet" href="/css/themecolor.css" />
    <!-- ThemeColor end -->
    
 
    <!--新东西 -->

    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          C++ - Zirpon | Blog
        
    </title>

    <link rel="canonical" href="/2023/05/31/C++/">



    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="body--home">

    <!-- ThemeColor -->
	
    <!-- ThemeColor -->
<!-- <div class="toggle" onclick="document.body.classList.toggle('body--dark')">Switch Color</div> -->

<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <strong class="mdui-icon material-icons bright-mode">🤡</strong>
  <strong class="mdui-icon material-icons dark-mode">🤡</strong>
</div>

    

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://zirpon.github.io/undefined')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                        </div>
                        <h1>C++</h1>
                        <h2 class="subheading"></h2>

                        <span class="meta">
                            Posted by Zirpon Cheung on
                            2023-05-31
                        </span>

                        
                            <!-- WordCount start -->
                            <div class="blank_box"></div>
                            <span class="meta">
                              Estimated Reading Time <span class="post-count">112</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <span class="meta">
                              Words <span class="post-count">27.8k</span> In Total
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                            <!-- WordCount end -->
                        

                    </div>
                


                </div>
            </div>
        </div>
    </div>

    
        <!-- waveoverlay start -->
        <div class="preview-overlay">
          <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
            <defs>
              <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
            </defs>
            <g class="preview-parallax">
              <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
              <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
              <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
              <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
            </g>
          </svg>
        </div>
        <!-- waveoverlay end -->
    
</header>

    
    <!-- Navigation (contains search)-->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Cheung Zirpon</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
          
          <li><a class="popup-trigger" title="Search"><span class="search-icon"></span>Search</a></li>
          
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>


<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 article-container">

                <p><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">cppreference.com</a></p>
<h1>高质量C++</h1>
<h2 id="1-C-C-程序-基本概念"><a class="header-anchor" href="#1-C-C-程序-基本概念">¶</a>1. C++/C 程序 基本概念</h2>
<p>内存页<br>
缺页中断 页面调度 页面交换</p>
<p>动态内存分配 运行时搜索</p>
<p><code>ocrmypdf  --sidecar test4.txt -l chi_sim+eng --deskew --jobs 4 -s 高质量程序设计指南_C++_C语言_第三版_扫描版.pdf test4.pdf</code></p>
<p>内部名称 <code>_main</code></p>
<p>C的连接规范<br>
C语言中<br>
编译单元（文件作用域） static函数<br>
extern 连接类型 global 作用域的 全局函数</p>
<p>C++<br>
作用域：编译单元 class struct union namespace<br>
同一个作用域同名函数 —— 重载函数</p>
<p>name-manglin</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample_1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> m_name[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* newName)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sample_1_foo@pch@<span class="number">1</span> </span><br><span class="line">Sample_1_foo@<span class="keyword">int</span>@<span class="number">1</span> </span><br><span class="line">Sample <span class="number">2</span>_foo@pch@<span class="number">1</span></span><br><span class="line">Sample_2_foo@<span class="keyword">int</span>@<span class="number">1</span></span><br><span class="line">Lippman的《inside The C++ object model》</span><br></pre></td></tr></table></figure>
<p>连接规范 linkage specification</p>
<p>关系到编译器采用什么样的name-mangling方案重命名这些标识符的问题</p>
<p>同一个标识符在不同的编译单元或模块中具有不一致的连接规范 就会产生不一致的内部名称 导致程序连接失败</p>
<p>通用连接规范属 C连接规范 extern “C”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 函数 变量 常量 指定连接规范</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">WinMainCRTStartup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">const</span> CLSID CLSID_DataConverter;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span>......&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> Student g_Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码限定连接规范</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明指定某个标识符 连接规范为 exter"C" 其对应定义也要指定extern "C"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _cdecl <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">sizt_t</span>)</span></span>; <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> _cdecl <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* p, <span class="keyword">const</span> <span class="keyword">void</span>* a , <span class="keyword">sizt_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....<span class="comment">//功能实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>C++/C 中 ， 全 局 变量 (extern或 static 的 ) 存放 在 程序 的 静态数据 区<br>
全 局 变量 提供 初 值 编 译器会 自动 地将 0 转换 所 需要 的 类 型 来 初始 化 它们</p>
<p>无 法 决定 当两 个 编译 单元连接 在 一 起 时 哪 一 个 的 全 局 变量 的 初始 化 于 另 一 个 编译 单元 的 全 局变量 的 初始 化</p>
<p>启动 函数 、IO 系统 函 数 存储 管理 、RTTI、 动态决议 动 态 链接 〈DLL) 等 都 会 调用 C 运行 时 库中 的 函数<br>
C 运行 时 有 多 线程 和 单线 程</p>
<p>编译 预 处 理 、 编译 和 连接 器 工作 的 阶段 合 “ 编 译 ”。</p>
<p>预 编译 伪 指令 类 〈 型 定义 外部 对 象 声 、 函 数 原型、 标识符 、 各 种修饰符号 (const、static 等 ) 及 类 成 员 的访问说 明 符 (public、private、protected) 和 连接 规范 调 用 规范 等仅在 编译 器进行 语法检查 、 语 义 检查 和 生成 目标文件 〈.obj 或 .o 文件 ) 及 连接 的 时 候起 作用 的</p>
<p>容器 越界，访问 虚 函数 ，动态 决议 ，函 数 动态 连接 、 动 内 存 分 配 异 常 处 和 RTTI等则 是在 运行 时 才 会 出 和 发 作用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pInt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">pint += <span class="number">100</span>;                         <span class="comment">// 越界 但 是 还 没有 形成 越界 访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pInt&lt;&lt;<span class="built_in">endl</span>;          <span class="comment">// 越界 访问 ! 可 能 行 也 可 能 不 !</span></span><br><span class="line">*pInt = <span class="number">1000</span>;                      <span class="comment">// 越界访问 ! 即使偶尔 不 出问题 但 不能 确保永远不 出问题 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="string">"Base::Say() was invoked!\n"</span>; </span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>: / 改变 访问 权限 合 法但 不 是好 风格 !</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Say</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Derived::Say() was invoked!\n”;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;Say(); <span class="comment">//输出: Derived::Say() was invoked !</span></span><br><span class="line"><span class="comment">// 出 乎 意料 地绑 定 到 了 一 private 函数 身上</span></span><br></pre></td></tr></table></figure>
<p>独立编译技术<br>
每 一 个 源代| 码 文件 〈 源 文件 及 其 递归 包含 的 有 头 文件 展开 ) 就 是 一 个 最小 的 编译 单元 每 个 编译 单元 可 以独立 编译 而不 需要 知道 他 编译 单元 的 存在 及 其 编译 结果 。</p>
<p>32位 操作 系统 上 ，int 类 型 的 变量 就 拥有 4 字 节 的 内 存单 元 而 double 类 型 的 变量 占 8 字 节 的 内 存单</p>
<pre><code>标准 C 语言 支持 基本 〈 内 ) 数据 类 有 int、long、float、double、char、void， 以 及 它们 和 signed、unsigned、*、&amp; 等 的 组 《 有些组 合 是 不 支持 的 例 如 void&amp; )。 标准 C++ 在 这 些 类 型 的 基础 上 增加 了 bool 类 型 并 同时 增加 了 两 内 置 的 符号 常量 true All false (Se).
</code></pre>
<p>标准 C 中 ，int 为 默认 类 型 也 就 是 说 如果 你 明确 指定 函数 的 形 类 型 或函数返回值类型 则它们的类型为 int,<br>
标准C++不支持默认类型，但在模板中 有 “默认 类 型 参数 ”的 概念 。</p>
<p>某些 基于 RISC《〈 精 简 指令 集计 算 机 ) 的 CPU 比如 SPARC、PowerPC 等<br>
对 内存 中 基本 数据类 型 变量 采用<br>
高 字 节 (BYTE) 和 高 (WORD) 在 低地 址 存放 、 低字节 和 低 字 在 地 址 存放 的<br>
Big Endian 存储格式 〈 即 高 字 节 、 高 字 在 前 或 地 址 大的 字 节 结尾 ),<br>
并 且 把 最 高 字节 的 地 址 作为 变量 的 首 地址</p>
<p>。在 这 种 自然 的 存储 格式 中 ，<br>
| 要求 变 量在 内 存 中 的 存放 位 必须 自然 对 ,否则 CPU 会 报告 异常 所 谓 自然 对齐 ，<br>
| 就 基本数据 类 〈 主 要 short、int 和double) 的 变量 不 能 简单 地 存储 于 内 存 中 的<br>
任意 地 址 处 它 们 的 起 地 址 必须 能 够 被 它们 的 大 小 整除</p>
<p>在 32 位 平台 下 ，int 和 指针 类 型 变量 的 地 址 应 该 能 4 整除，而 short 变量 的 地 址 都应 该 是 偶数 ，bool和 char 则 没有 特别 要 求</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531104928.png" alt=""></p>
<p>Intel 系列 CPU 采用 Little Endian 存储 格式 来 存放 基本 类 型 变量 即 低 字节和低字 在 低地 址 存放 、 高 字 节 和 高 字 在 地 址 存放 《〈 即 低 字 节 、 低 字 在 前 或地 址 小 的 字 节 结尾 )， 并 且 把 最低 字节 的 地 址 作为 变量 的 首 地 址</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531105144.png" alt=""></p>
<h2 id="隐式转换"><a class="header-anchor" href="#隐式转换">¶</a>隐式转换</h2>
<p>显 地 使 用 强制 类 型 转换由 此 可 能 造成 的 安全 隐患 由 程序 员 负 责<br>
这 里 安全 性 主要包括 两 个 方面 内 存单 元访问 的 安全 和 转换 结果 的 安全 性<br>
主要 表现<br>
内 存 访问 范围 的 扩张<br>
内 存 的 截断<br>
尾 数 的 截断<br>
值 的 改变 和<br>
溢出<br>
一 个 低级 数据 类 型 对 象 总 是 优先 转换 为 能 够 容纳 得 下 它 的 大 值 的、 占用 内 存;最少 的 高 级 类 型 对 象</p>
<p>示例 4-5 中 的 转换 是 安全 的 并 不 需要 强制 编 译 器</p>
<p>首先 隐 式 地 100 提升: double《〈 作 为 它 的 整数 部 分 的 一 个 临时 变量<br>
然 才 将这 个 临时 变量 赋值 dl;<br>
同样 ，i 也 会 首先 隐 式 地 提升 double《〈 其 值作为 它 的 整数 部 ) 的 一 个 临时 变量 ，<br>
| 然后 才 赋值 d2。<br>
当 编译 器 认为 这 些 临时 变量 不再 需要 时 就 适时 地 把 它们 销毁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span>-$</span><br><span class="line"><span class="keyword">double</span> di = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> i= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = i</span><br></pre></td></tr></table></figure>
<p>直接 将派生 类对 象 转换 基 类 对 ，这 虽然 会 生 内 存 截断 但 是 无 从 内 存 访问 还 从 转换 结果 来说 都是 安全</p>
<p><a href="git-repos/gitee/blog/source/_posts/!%5B%5D(git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531114341.png).md">Pasted%20image%2020230531114341.png)</a><a href="git-repos/gitee/blog/source/_posts/%E6%96%B0%E7%89%B9%E6%80%A7.md">新特性</a></p>
<p>C 语言 环境 中 我们 可 以 先 把 一 种 具体 类 型 指针<br>
如 int* 转 换 void* 类 型 然<br>
再 把void* 类 型 转换 double* 类 型<br>
而 编译 器 不 认为 这 是错误 。 然 这样的 做 法 确实 存在 着 不 易 察 党 的 安全 问题<br>
( 内 存 扩张 和 截断 )， 这 是 标准C 语 言 的 一 个 缺陷</p>
<h3 id="强制转换"><a class="header-anchor" href="#强制转换">¶</a>强制转换</h3>
<h3 id="数据类型转换"><a class="header-anchor" href="#数据类型转换">¶</a>数据类型转换</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d3 = <span class="number">1.25e+20</span>;</span><br><span class="line"><span class="keyword">double</span> d4 = <span class="number">10.25</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = (<span class="keyword">int</span>)d3;</span><br><span class="line"><span class="keyword">int</span> i3 = (<span class="keyword">int</span>)d4;</span><br><span class="line"></span><br><span class="line">按照 从 浮 点 数 到 整 型 数 的 转换 语义 结 果 应 是 截 去 浮 点 数 的 小 数部分而 保留其 整数 部分</span><br><span class="line">因 此 i 会得 到 <span class="number">10</span>，</span><br><span class="line"></span><br><span class="line">d3 的 整数 部 分远远 超 了 一 个<span class="keyword">int</span> 所 能 表示 的 范围 </span><br><span class="line">i2 会 溢出</span><br></pre></td></tr></table></figure>
<h3 id="指针转换"><a class="header-anchor" href="#指针转换">¶</a>指针转换</h3>
<p>基本 数据 类 型 间 的 <strong>指针转换</strong> 一 般 说 必然 造成 内 存 截 断 或 内 存 访问 范围扩张<br>
在 32 位 系统 ，int、long、float 都 具有 4 字 节 的 空间<br>
虽 然 不 会 造成 内 存 截断 内 存 扩张<br>
它们 之间 的 <strong>指针 转换</strong><br>
改变 了 <strong>编译 器</strong>对 指针 所指向 的 内 存单 元 的 <strong>解释方式</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span><span class="number">-8</span></span><br><span class="line"><span class="keyword">double</span> d5 = <span class="number">1000.25</span>;</span><br><span class="line"><span class="keyword">int</span> *pInt = (<span class="keyword">int</span>*)&amp;d5;</span><br><span class="line"><span class="keyword">int</span> i4 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> *pDbl = (<span class="keyword">double</span>*)&amp;i4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从 内 存 访问 角度 来 , 你 通过 pInt 访问 它 指向 <span class="keyword">double</span> 类 型 变量 d5 是 安全 的</span><br><span class="line">(后面的 <span class="number">4</span> 字 节 “截断 ”了 ， 可访问 内 存 范围 缩小 )，但 是 其 值 绝对 不 会 d5 的 整数部分<span class="number">1000</span>， </span><br><span class="line">而 是 位 d5 开头 <span class="number">4</span> 字节 中 的 内 容 并 解释 <span class="keyword">int</span> 类 型 数 </span><br><span class="line">这 个 数 是 不可预料 的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过 pDbl 访问 <span class="keyword">int</span> 类 型 变量 这 ， 得 到 的 数据 不一 定 就 <span class="number">100</span>， 况 且造成 了 可 访问 内 存 范围 “扩张 &gt;。 </span><br><span class="line">如 果 你往 里 面 写 数据 就 会 产生 运行 时 错误</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531131558.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base objB2;</span><br><span class="line">Derived *pD2 = (Derived *)&amp;objB2;</span><br><span class="line"></span><br><span class="line">存在 的问题 : 通过 pD2 能 够 访问 的 内 存范围 “扩张 ”了 <span class="number">4</span> 字节 ,如果 访问 m_c可 能 引发 运行 时 错误 ,因为 pD2 指向 的 对 象 根本 就 没有 成 m_e 的 空间</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531131959.png" alt=""></p>
<p>(1) 不 可 以 <strong>基 类</strong> 对 象 直接 转换 为 <strong>派生 类</strong> 对 象 无 论 直接 <strong>赋值</strong> 还 是<strong>强<br>
制 转换</strong> 因 为 这 不 “自然 的 ”;<br>
(2) 对 于 <strong>基本 类 型</strong> 的<strong>强制 转换</strong> 一 定 要 区 分 <strong>值的截断</strong> 与 <strong>内 存 截断</strong> 的 不 同;<br>
(3) 如 果 你 坚持 要使 用强制 转换 必 须 同时 确保 <strong>内存访问的安全性</strong> 和 <strong>转换结果的安全性</strong> ;<br>
(4) 如 果 确信 需 要 数据 类 型 转换 请 尽量使 显 式 ( 即强制 ) 数据 类型 转换 让 人 们 知道 发 了 什么 事 避 免让 编译 器 静 悄悄地 进行 隐 式 的数据 类 型 转换 。</p>
<h3 id="标识符"><a class="header-anchor" href="#标识符">¶</a>标识符</h3>
<p>标 识 符 可 以 任意 长<br>
但 是 标准 C 语言规定 编 译器 只 取 前 31 个字符 作为 有 效 的 标识符<br>
而 标准 C++ 则 取 前 255 个 字符 作为 有 效 的 标识 。</p>
<p>每 一 个 标识 符 都 具有 如 下 的 几 个 属性<br>
值<br>
值 类 型<br>
名 字 、<br>
存 储 类 型<br>
作 用域范围<br>
连 接 类 型 （可 见 性)、<br>
生 存 期 等</p>
<p>C 函数 函 数 名 其 实 就是<br>
函数 代码<br>
在 内 存 中 的 首 地 址 在 编译 时 就 可 以 确定 其 值 因 此 是 一 个 常量 这 是 它 的 值<br>
值的 类 型 是 函数 指针 类 型<br>
存 储 类 型 默认 extern， 除 非 声明 为 static;，<br>
作 用 域 范围为 文件 作用域 ;<br>
连接 类 型 默认 为 外 连接 , 除非 声明 为 static;<br>
生存 期 为 永久 〈 即 静态 )。</p>
<h3 id="转义序列"><a class="header-anchor" href="#转义序列">¶</a>转义序列</h3>
<h3 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h3>
<h4 id="算术运算符-关系运算符-逻辑运算符"><a class="header-anchor" href="#算术运算符-关系运算符-逻辑运算符">¶</a>算术运算符 关系运算符 逻辑运算符</h4>
<h4 id="函数调用-类型转换-成员选择"><a class="header-anchor" href="#函数调用-类型转换-成员选择">¶</a>函数调用 类型转换 成员选择</h4>
<p>类型转换运算符<br>
运行时类型识别运算符（typeid）<br>
作用域解析(::)<br>
动态内存分配 释放<br>
类成员指针运算符</p>
<h4 id="运算符基本特性就是优先级和结合律"><a class="header-anchor" href="#运算符基本特性就是优先级和结合律">¶</a>运算符基本特性就是优先级和结合律</h4>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531133944.png" alt=""></p>
<h3 id="表达式"><a class="header-anchor" href="#表达式">¶</a>表达式</h3>
<h3 id="常量表达式-算术表达式-关系表达式-逻辑表达式-复合表达式-逗号表达式-条件运算符表达式-位运算表达式"><a class="header-anchor" href="#常量表达式-算术表达式-关系表达式-逻辑表达式-复合表达式-逗号表达式-条件运算符表达式-位运算表达式">¶</a>常量表达式 算术表达式 关系表达式 逻辑表达式 复合表达式 逗号表达式 条件运算符表达式 位运算表达式</h3>
<p>常量表达式在编译时就可求值</p>
<p>能 够 在 编译 时 求 的 程序 元 素 是 否需要 分 配 运行 时 的 存储 空间 呢 ?</p>
<ol>
<li>
<p>基本 数据 类 型 的 字面常量 枚举常量 、sizeof()、 常 量 表达 式 等 就 不需要分配存储 空间 ， 因 此 也 没有 存储 类型</p>
</li>
<li>
<p>字符 串 常 量 、const 常量 (尤其 ADTUDT 的 const 对 ) 都 要 分配 运行 时 的 存储 空间 即 有 特定 的 存储 类 型</p>
</li>
</ol>
<p>在 用 运算 “&amp;&amp;” 的 表达 式 ， 要 尽量 把 有 可 能 FALSE 的 表达 式 放在 “&amp;&amp;” 的 左边<br>
在 用 运算 “||” 的 表达 式 中 要 尽量把 有可 能 TRUE 子表达式 “||” 左边.</p>
<h3 id="基本控制结构"><a class="header-anchor" href="#基本控制结构">¶</a>基本控制结构</h3>
<h3 id="选择判断结构"><a class="header-anchor" href="#选择判断结构">¶</a>选择判断结构</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设 有 两 个浮 点 变量 x 和 y， 精 度 定义 EPSILON = le<span class="number">-6</span>， 则 错误 的 比较 方式</span><br><span class="line">如下:</span><br><span class="line">	<span class="keyword">if</span>(x = y) / 隐 含 错误 的 比较</span><br><span class="line">	<span class="keyword">if</span>(x != y) / 隐 含 错误 的 比较</span><br><span class="line">应 该 转化 为 正确 的 比较 方式 :</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(x - y) &lt;= EPSILON) Ux Fy</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(x - y) &gt; EPSILON) Ux BEF y</span><br><span class="line">同 理 ，x 与 零 值比较 的 正确 方式 :</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span> (x) &lt;= EPSILON) /x 等 <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span> (x) &gt; EPSILON) Ix REF <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>if (NULL == p)</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531135348.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531135436.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531135630.png" alt=""></p>
<p>数组 元 素 的 访问 是 真正 的 随机 访问 〈 直 接地 址 计算 )。 如 果 整个 数组 能 在 一<br>
内 存 页 中 容纳 ， 那 么 在 对 整个 数组 进行操作 的 过 中 至少不 会 了 访问 数组 元 素<br>
而 出 现 缺 页 中 断 页 面 调度 和 页 交换 等 情况 只 需要 一次 外 存 读取 操作 就 可 以<br>
数组 所 在 的 整个 页 面 入 内 存 然 后 直接 访问 内 存 可 了</p>
<p>在 示例 4-14 中 ， 左 边 的 写法 比 右边 的 写法 多 执行 Nr] 次 逻辑 判断 并 且前 者<br>
的 还 辑 判断 打 了 循环 “流水 线 ” 作 ， 使 得 编译 器 不 能 对 循环 进行 优化 处 ，<br>
降低 了 效率 如 果 和 非常 大 最好 采用 右边 的 写法 可 以 提高 效率 如 果 N 非常 小 ，<br>
两 者 效率 差别 并不 明显 采 用 左边 的 写法比较 ， 因 为 程序 更 加 简洁 。</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230531140922.png" alt=""></p>
<h2 id="2-第五章-常量"><a class="header-anchor" href="#2-第五章-常量">¶</a>2. 第五章 常量</h2>
<h3 id="字面常量"><a class="header-anchor" href="#字面常量">¶</a>字面常量</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-100.25f</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN SUCCESS 0x00000001</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *pChar = <span class="string">"abcdef"</span>; / 取 字 符 串常量的地址</span><br><span class="line">intt *pint = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">保存在符号表里 无法取地址</span><br></pre></td></tr></table></figure>
<p>编译链接环境支持常量合并的 请打开</p>
<h3 id="符号常量"><a class="header-anchor" href="#符号常量">¶</a>符号常量</h3>
<p><code>#define</code> 预编译伪指令 字面常量<br>
const 分配存储空间 外连接</p>
<h3 id="C-中-，const定义-的-常量-要-具体情况-具体-对-待"><a class="header-anchor" href="#C-中-，const定义-的-常量-要-具体情况-具体-对-待">¶</a>C++ 中 ，const定义 的 常量 要 具体情况 具体 对 待</h3>
<p>对 于 <strong>基本数据 类 型 的 常量</strong> 编 译 器 把 它 放 到 符号 表 中 而不 分 配 存 储空间 ,<br>
而 ADITVUDT 的 <strong>const 对 象</strong> 则 需要 分配 存储 空间 (大对象)。<br>
还 有 一 些情况 下也 需要 分 配 存储空间 ，<br>
例如 强制 声明 为 extern 的 符号常量<br>
或者 取 符号常量的地址 等 操作 ，<br>
都 将强迫 编译 器 为 这 些 常量 分 配 存储 空间 以 满足 用 户 的 要 求</p>
<p>对于 <strong>基本 数据 类 型 const 常量</strong> 编 译器 重新 在 内 存 中 创建 它 的 一 个 <strong>拷贝</strong><br>
你 通过 其 地 址 访问 到 的 就 这 个 拷贝 而 非 原始的 符号 常量</p>
<p>对 于 构造 类 型 const 常量 实 上 它 是 编译 时不 允许修改 的 变量 ，<br>
因此 如 果 你 能 绕 过 <strong>编译 器 的 静态 类 型 安全 检查机 制</strong> 就 可 以 在 运行 时 修改 内 存单 元，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> Ing = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">long</span> *pl = (<span class="keyword">long</span>*)&amp;lng; / 取 常 量 的 地 址</span><br><span class="line">*pl = <span class="number">1000</span>; <span class="comment">//迂回修改</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pl &lt;&lt; <span class="built_in">endl</span>; / <span class="number">1000</span>， 修 改 的 是 拷贝 内 容 !</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Ing &lt;&lt; <span class="built_in">end</span>]; / <span class="number">10</span>， 原 始 常量 并 没有 变 !</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Integer() : m_Ing(<span class="number">100</span>) &#123; &#125;</span><br><span class="line">	<span class="keyword">long</span> m_Ing;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Integer int_1;</span><br><span class="line">Integer *pInt = (Integer*)&amp;<span class="keyword">int</span> <span class="number">1</span>; <span class="comment">// 去除常数属性</span></span><br><span class="line">pint-&gt;m_Ing = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pInt-&gt;m_Ing &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1000, 修改const 对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; int_].m_Ing &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1000, 迂回修改成功</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>在 标准 C 语言 中 ，const 符号 常量 默认 是 外 连 楼 〔 分 配 存储 )，<br>
也 就是说你不能在两个或以上编译单元中同时定义一个同名的const符号常量<br>
也不能 把 一 个const 符号 常量 定义 放 在 一 个头文件 中 而 在 多 个 编译 单元 中 同时 包含 头 文件</p>
</li>
<li>
<p>但 是 在 标准 C++ const符号 常量默认 是 内 连接 的 因 此 可 以 定义 在 头 文件 。<br>
当 在 不 同 的 编译单元 中 同时 包含 头 文件 时 编 译 器 认为 它们 是 不 同 的 符号 常量<br>
因 此每 个 编译 单元独立 编译 时 会 分 别 为 它们 分配 存 储 空间 ，<br>
而 在 连接 时 进行常量 合并</p>
</li>
</ol>
<h3 id="契约性常量"><a class="header-anchor" href="#契约性常量">¶</a>契约性常量</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">5</span><span class="number">-3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n= <span class="number">0</span>;</span><br><span class="line">	ReadValue(n); <span class="comment">// 契约性 const, n 被 看 做 const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举常量"><a class="header-anchor" href="#枚举常量">¶</a>枚举常量</h3>
<p>标 C++规定 枚 举 常量 的 值 可 以 扩展 的 并 非 受 限 于 一 般 的 整 数 的 范围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Gigantic</span><br><span class="line">&#123;</span><br><span class="line">	SMALL = <span class="number">10</span>,</span><br><span class="line">	GIGANTIC = <span class="number">300000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 底层 如 何 实现 则 依赖 于 具体 的 环境 和 编译 器 厂商 可 能 会 不 同 的 语义 ，<br>
请 查看 编译 器 文档</p>
<p>以 C++ 程序 中 应 尽量 使 const 来 定义 符号 常量 包 括 字符 串 常量 。</p>
<p>非 静态 const 数据 成 员 是 属于 每 一对 象 的 成 员 <strong>只在某个对象生存期内是常量</strong><br>
而 对 于 整个 类 来 说 它 是 可 变 ，<br>
除非 static const。</p>
<p>因 为 类 可 以 创建 多 个 对 象 不 同 的 对 象 const 数据 成员 的 可以 不 同</p>
<p>不 能 在类声明 中初始 化 非 静态 const 数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;   / 错误 企 图 在 类 声明 中初始 <span class="keyword">const</span> 数据 员</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">array</span>[SIZE];           / /错误 未 知 SIZE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>非 静 const 数据 员 的初始化 只 能 在 类 的 构造 函数 的初始 化 列表 中 进行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	...</span><br><span class="line">	A(<span class="keyword">int</span> <span class="built_in">size</span>); / 构造 函数</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> SIZE ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::A(<span class="keyword">int</span> <span class="built_in">size</span>) : SIZE(<span class="built_in">size</span>) / 构造 函数 的初始 化 列表</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">A all00);   <span class="comment">// HR a HK SIZE (AA 100</span></span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">200</span>)</span>   <span class="comment">// AR b HY SIZE &#123;4% 200</span></span></span><br></pre></td></tr></table></figure>
<p>怎样才能 建立 在 整个 类 中 都 恒定 的 常量 ? 别 指望 const 数据 成员 了 ，<br>
应该 用 类 中 的 枚 举 常 量 来 实现<br>
枚举 常 量 不会 占用 对 象 的 存储 空间 它 们 在 编译 时 被 全 部 求 值<br>
更 何况 它 定义的 是 一 个 匿名 枚 举 类 型<br>
枚 举 常 量 的 缺点 是 不 能 表示 浮 点数 〈 如 PI-=3.14159) 和 字符串</p>
<p>可 以 用 另 一 种 方法 来 定义 类 的 有 对 象 共享 的 常量 ，即 static const，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">5</span><span class="number">-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>: <span class="comment">// 有 些语言 实现 可 能 不 支持 这样 的初始 化 如 Visual C++</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE1 = <span class="number">100</span>; / 静态常量 员</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE2 = <span class="number">200</span>; / 静态 常量 员</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">array</span> <span class="number">1</span>[SIZE1]; <span class="comment">// 普通 员</span></span><br><span class="line">	<span class="keyword">int</span> array2[SIZE2]; <span class="comment">// 普通 员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实际-用-中-如-何-定-义-常量"><a class="header-anchor" href="#实际-用-中-如-何-定-义-常量">¶</a>实际 用 中 如 何 定 义 常量</h3>
<h4 id="1-C程序"><a class="header-anchor" href="#1-C程序">¶</a>1. C程序</h4>
<h5 id="1-1-多个编译单元或模块公用"><a class="header-anchor" href="#1-1-多个编译单元或模块公用">¶</a>1.1 多个编译单元或模块公用</h5>
<p>1.1.1 在某个公用头文件中将符号常量<strong>定义为static并初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX+LENGTH =<span class="number">1024</span>;</span><br><span class="line">``` </span><br><span class="line">然后每一个使用它的编译单元 `<span class="meta">#<span class="meta-keyword">include</span>` 该头文件即可；</span></span><br><span class="line"><span class="number">1.1</span><span class="number">.2</span> 在头文件中使用 **宏定义**</span><br><span class="line"><span class="number">1.1</span><span class="number">.3</span> 在 某个公用的头文件中将符号常量声明为**<span class="keyword">extern</span>**</span><br><span class="line">```C++</span><br><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_LENGTH;</span><br></pre></td></tr></table></figure>
<p>并且在某个源文件中<strong>定义一次</strong>;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后每个使用它的编译单元<code>#include</code> 上述头文件即可<br>
1.1.4 整形常量 在某个公用<strong>头文件</strong>定义<strong>enum</strong>类型 然 后 每 一 个使 用 它 的 编 详单 <code>#include</code> 该头 文件 即 可</p>
<h5 id="1-2-只为一个编译单元使用"><a class="header-anchor" href="#1-2-只为一个编译单元使用">¶</a>1.2 只为一个编译单元使用</h5>
<p>1.2.1 直接于编译单元开头位置将符号常量定义为static 并初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>1.2.2 同1.1.1<br>
1.2.3 同1.1.3 或在编译单元开头定义enum类型</p>
<h4 id="2-C-程序"><a class="header-anchor" href="#2-C-程序">¶</a>2. C++程序</h4>
<h5 id="2-1-多个编译单元或模块公用"><a class="header-anchor" href="#2-1-多个编译单元或模块公用">¶</a>2.1 多个编译单元或模块公用</h5>
<p>2.1.1 在某 个 公用 的 头 文件 中 直接 在 某 名 字 空间 中 或者 全 局 名 字 空间 中 定义 符号常量 并 初始 化 有 无static无 所 谓 )， 例 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>每一个使用它的编译单元 <code>#include</code> 该 头 文件 即 可<br>
2.1.2 在 某 公用 头 文件 中 并 且 在 某 名 字 空 间 中 或全 局 名 字 空 间 中 将 符号 常量 声明为 extem 的 例 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX LENGTH;</span><br></pre></td></tr></table></figure>
<p>并 且在 某 个 源 文件 中 定义 一次 并 初始 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后 每 一 个使 用 它 的 编 详 单元 机 nclude 上 述 头 文件即可<br>
2.1.3 同1.1.3<br>
2.1.4  定义 为 某 一 个 公用 类的 static const 数据成 员 并 初始<br>
或 者定义为 类 内 的 枚 举 类 型 例 如 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utility.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utility</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX LENGTH;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">TIME_OUT= <span class="number">10</span></span><br><span class="line">hs</span><br><span class="line"><span class="comment">// Utility.cpp</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Utility:: MAX LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后 每 一 个使 用 它 的 编 详 单元 机 nclude 上 述 头 文件即可</p>
<h5 id="2-2-只为一个编译单元使用"><a class="header-anchor" href="#2-2-只为一个编译单元使用">¶</a>2.2 只为一个编译单元使用</h5>
<p>2.2.1 同2.1.1<br>
2.2.2 直接 于 该 编译 单元 〈 源 文件 开头 定义 符号<br>
量 并 初始 〈 有 无 static 无所 谓 )， 例 如 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.C</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>2.2.3 同1.2.3</p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h3>
<p>在 C 程序 中 ，const 符号 常量 定义 的默认 连接 类 (Linkage) 是 extern 的 即 外连接 (external linkage)， 就 全 局 变量 一 样<br>
因 此 ， 如 果 要 在 头 文件 中 定义 必 须使用 static 关键字 ，<br>
这 样 每 一 包含 头 文件 的 编译 单元 就会 分 别 有 该 常量 的 一份独立定 义 实体 〈 如 同 直接 在 每 一 个源 文件 中 分 别 定义 一 )，<br>
否则会 导致 “redefinition”的 编译 器诊断 信息 ;<br>
如果 在源 文件 中 定义 除 非 明确 改变 它 的 连接 类 型 static 〈 实际 上 是 存储 类 型 static, 连接 类 型 内 连接 ) 的 ,<br>
否则 其他 编译 单元 可 以通过 extern声明 来访问</p>
<p>C++ 程序 ，const 符号 常量定义 的 默认 连接 类 型 却 static 的 即 内 连(Cinternal linkage)，<br>
就 class 的 定义 一 样 这就是在 头 文件 中 定义 而 不 需要 static关键 字 的 原因</p>
<p>字符 串 常量 的 定义 和 整 型 常量 的 定义 差不多 ， 但 是其类 型 <code>const char *</code>， 因 此<br>
们 常常 这样 定义 它们 ;</p>
<p>const char* const ERR_DESP NO_MEMORY = “There is no enough memory!”;</p>
<p>可 以 在头 文件 中 定义 并初始 ， 也 可 以 在 源 文件 中 定义 并 初始 化 但 是 二 者 差别 大 :</p>
<ol>
<li>
<p>如 果 在 头 文 件 中 定义 并 初始 化 那 包含 了 该 头 文件 的 每 一 个 编译 单元<br>
不仅 会 为 一个 常量 指针 常量 (const char * const) 创建 一 个独立 的 拷贝项 ，<br>
而 且 也 会 为 那个 长长 的 字符 串 字 面 量 创建 一 个独立 的 拷贝 项<br>
就 相当 于在 每 一 个 编译单元 内 分 别 定 和 初 始化每 一 个 常量 ， 一次 一 个 样<br>
这是与 整 型 或浮点 型 常量 的 定义 不 同 〈 它 们 在初始化 完 后 不 再 需要 那个 字面<br>
营 )。<br>
因 此 ， 每 一 个 编译单元 内 访问的 字符 串 常量 都 是它 自己 单独 创建 :<br>
拷贝 衬间 的 开销 就 体现 在每 一 字符 串 字 面 量 的独立拷贝 上 ;</p>
</li>
<li>
<p>如 果 采 用 方法 ， 在 头 文件 中 声明 所有 常量 指针 常量 而在 源 文 中 定义并初始化 它们 ，<br>
则 每 一 包含 头 文件 的 编译 单元 访问 的 不 仅 是 常量 指针常量 的 唯一 实体<br>
而 且 字 符 串 字面 常量 也 是 唯一 的实体<br>
这就 大 节约 了内 存 而卫 不 失效 率。<br>
当然 我 们 完全 可 以 把 常量 合并 的 优化 交 给 编译 和 连接 器 来 完成 但 是 我 们</p>
</li>
</ol>
<p>还 是 提倡 由 自己 来 优化 常量 的 定义 。</p>
<h2 id="3-函数"><a class="header-anchor" href="#3-函数">¶</a>3. 函数</h2>
<p>对 于** 静态 链接 库** 的 函数 库 或 类 库 如 果 你 调用 了 其 中 的 函数 《无 论 是 直接 调用<br>
还 是 间接 调用 )，<br>
那 么 连接 器 从 相应 的 中 提取 这 些 函数 的 实现 代码 并 把它们 连接到 你 的 用 程序 ;<br>
如 果 你 没有 调用 库 中 的 某 些 函数 则 连接 器 是不 会把 它们 的 实现代 码 连接 进来 的 即 使 该 包含 了 成 上 万 个 函数</p>
<p>如 果 你 用 的 是 动态 链接(DLL)， 则 运行 时 必须 将 有 DLL 都 找 到 运行 环境 的 相应 目录 下</p>
<p>如 果 程 中 任何 地 方 都 没有 调用 你 自己 编写 的 某 个 函数 的 话<br>
编译器也不 会 为 函数 生成 可 执行 代码</p>
<h3 id="函数原型-定义"><a class="header-anchor" href="#函数原型-定义">¶</a>函数原型 定义</h3>
<p>早先 C 语言 存在 函数 <strong>前 置 声明</strong> 的 概念<br>
因 为 C 语言 环境 中 同 一 作用 域中 不 能 出 现 同名 的 全 局 函数</p>
<p>有 了 函数 前 声明 ， 即 把 函数 的 定义 体 放 在 函数 调用 后 面 的 任何 地 方 也 无 ，连接 器在 连接 时 能 够 找到 。</p>
<p>是 函数 前 置 声明 并 没有 给 出 函数 可 接受 的 参数 类 型和 个 数<br>
于 是 编译 器 无 法对 函数 调用 语句 执行静态 类 型 安全 检查<br>
〈 即 检查 实 参与参 的 个 数 类 型 及 顺序 等 是 呈 配 )。</p>
<p>导致 正确 的 参数 传递 从 而 出 现 运行时 错误 甚至 破坏 堆栈</p>
<p>解决 这 一问题 的 方法 就 是使 用 函数 原型 (ANSIISO C 从 C++ 借鉴 了 函数 原型 )。</p>
<p>{ 作 用 域 [函数 的 连接规范 ] 返回 类 [函数 的 调用 规范 ] 函数 (类 1 [ 形 参 1]，类型 2 [形参 2], …);</p>
<p>函数调用 中 参数 传递 本 质 就 用 实参 来 <strong>初始 化 形 参</strong> 而 不 是 替换 形参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> *p)</span></span>; dni p 是 形参</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">class</span> <span class="title">C</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *q = “abcd”;</span><br><span class="line">	f(<span class="number">5</span>, q); /<span class="number">5</span> 和 q 是 实参</span><br><span class="line">	C&lt;<span class="keyword">int</span>&gt; a; /<span class="keyword">int</span> 是实 参</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数堆栈"><a class="header-anchor" href="#函数堆栈">¶</a>函数堆栈</h3>
<p>函数 堆栈 实际 上 使 用 的 是 程序 的 堆栈 内 存 空间 ， 虽 然 程序 的 堆栈 段 是 系统程序 分 配 的 一 种 静态 数据 ， 但 是 函数 堆栈 却 是 在 调用 到 它 的 时 候 才 动 态 分 配</p>
<p>函数 堆栈 却 是 在 调用 到 它 的 时 候 才 动 态 分 配</p>
<p><img src="ebooks-copy/desktop/%E7%AC%AC5%E7%AF%87_C_C_%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%A0%88%20-%20%E7%9F%A5%E4%B9%8E%20(2023_6_1%2002_50_50).html" alt=""></p>
<p><a href="https://www.zhihu.com/column/c_1277937360727257088" target="_blank" rel="noopener">C/C++ 修道院 - 知乎 (zhihu.com)</a></p>
<p><img src="ebooks-copy/desktop/%E6%B5%85%E8%B0%88%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%20(2023_6_1%2002_57_45).html" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601024956.png" alt=""></p>
<p><strong>栈段：</strong></p>
<p>1. 为函数内部的局部变量提供存储空间。<br>
　　2. 进行函数调用时，存储“过程活动记录”。<br>
　　3. 用作暂时存储区。如计算一个很长的算术表达式时，可以将部分计算结果压入堆栈。</p>
<p><strong>堆：</strong></p>
<p>堆能够根据需要自动增长。堆区域是用来动态分配的内存空间，用 malloc 函数申请的，用free函数释放。calloc、realloc和malloc类似：前者返回指针的之前把分配好的内存内容都清空为零；后者改变一个指针所指向的内存块的大小，可以扩大和缩小，它经常把内存拷贝到别的地方然后将新地址返回。</p>
<p><strong>数据段（静态存储区）：</strong></p>
<p>包括BSS段（Block Started by Symbol）的数据段。BSS段存储未初始化或初始化为0的全局变量、静态变量，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。数据段存储经过初始化的全局和静态变量。</p>
<p><strong>代码段：</strong></p>
<p>又称为文本段。存储可执行文件的指令；也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<p>.**rodata段：**存放只读数据，比如printf语句中的格式字符串和开关语句的跳转表。也就是你所说的常量区。例如，全局作用域中的 const int ival = 10，ival存放在.rodata段；再如，函数局部作用域中的printf(“Hello world %d\n”, c);语句中的格式字符串&quot;Hello world %d\n&quot;，也存放在.rodata段。</p>
<p>但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：</p>
<p>1）有些立即数与指令编译在一起直接放在代码段。</p>
<p>2）对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份。</p>
<p>3）用数组初始化的字符串常量是没有放入常量区的。</p>
<p>4）用const修饰的全局变量是放入常量区的，但是使用const修饰的局部变量只是设置为只读起到防止修改的效果，没有放入常量区。<br>
　　5）有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率。</p>
<p>注意：程序加载运行时，.rodata段和.text段通常合并到一个Segment（Text Segment）中，操作系统将这个Segment的页面只读保护起来，防止意外的改写</p>
<h3 id="函数调用规范-调用约定-〈CallingConvention-。"><a class="header-anchor" href="#函数调用规范-调用约定-〈CallingConvention-。">¶</a>函数调用规范  调用约定 〈CallingConvention)。</h3>
<p>函 数 调用 规范 决定 了 函数 调用 的 **实 参 压 栈 退 栈 及 堆栈 释放 的 方式 **</p>
<p>Windows 环境 下 常用 的 调用 规范 :<br>
(1) <code>_cdecl</code>: 这 是 CHHC 函数 的 默认 调用 规范 ,参数 从右 向 左 依次 传递 并 压 入<br>
堆栈 由 调用 函数 负责 堆栈 的 清 退</p>
<p>(2) <code>_stdcall</code>， 这 是 Win API 函数使 用 的 调用 规范 。 参 数 从右 向 左 依次传递 并 压 入 堆栈 外 被 调用 函数 负责 摊栈 的 清 退<br>
该 规范 生成 的 函数 代码“cdecl 更 小， 但 当 函 有 可 变个 数 的 参数 时 会 转 为 <code>_cdecl</code> 规范<br>
(3) <code>_thiscall</code>: 是 C++ 非 静态 员 函 数 的 默认 调用 规范 不 能 用 个 数可 变 参数<br>
(4) <code>_ fastcall</code>: 该规范 所 修饰 的 函数 的 实 参 将 直接 传递 到 CPU 寄存 器 中 而 不<br>
是 内 存 堆栈 不能 用 于 成 员 函 数</p>
<p>凡是 接口 函数 必须 显 式 地 指定 其 调用 规范 除 接口 函数 类 的 非态 员 函 non-static member function)。</p>
<h3 id="函数的连接规范"><a class="header-anchor" href="#函数的连接规范">¶</a>函数的连接规范</h3>
<p>只 要 它们使 用 一 的 员 对 齐 方式 和 布局 方案 、 一 的 函数 调用 规范 、 一 致 virtual function 实现 方式 总 之就 是 一 致 C++ 对 象 模型</p>
<h3 id="参数传递规则"><a class="header-anchor" href="#参数传递规则">¶</a>参数传递规则</h3>
<p>C 语言 , 函数 的 参数 和 返回 的传递式 有 两 : 值传递 (pass by value) 和 地 址传递 〈 即 指针 传递 ，pass by pointer)</p>
<p>C++语言 中 增加 了 引用 传递 〈pass by reference)。</p>
<p>如 果 函 数 有 参数 那使 void 而 不 要 空 着<br>
这 是 因为 标准 C 把 的 参数 列表 解释 为 可 以 接受任何 类 和 个 数 的 参数<br>
而 标准 C++ 则 把 空 的 参数 列表 解释 为 可 以 接受任何 参数<br>
在 移植 C+HC 程序 时 尤其 要 注意 这 方面 的 不 同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>)</span></span>; / 良好 的 风格</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; / 不 良 风格</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">void</span>)</span></span>; / 良好 的 风格</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetValue</span><span class="params">()</span></span>; / 不 良 的 风格</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601050908.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601051429.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="keyword">operator</span> + (<span class="keyword">const</span> <span class="keyword">String</span> &amp;lh, <span class="keyword">const</span> <span class="keyword">String</span> &amp;rh)</span><br><span class="line">| &#123;</span><br><span class="line">	| <span class="keyword">String</span> temp;</span><br><span class="line">	temp.m_data = <span class="keyword">new</span> <span class="keyword">char</span>[strljen(s1.m_data) + <span class="built_in">strlen</span>(s2.m_data) + <span class="number">1</span>]];</span><br><span class="line">	<span class="built_in">strcpy</span>(temp.m_data, s1.m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(temp.m_data, s2.m_data);</span><br><span class="line">	retumtemp; /执行 <span class="built_in">string</span> 对 象 及 其 字符 串 内 容 的 拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 于相 加 函数 应 当 用 “返回 对 象 值 的 方式 返回 String 对 象 这 将把 局 部 对 temp 及 其 真正 的 字符 串 值 拷贝 一 给 调用 环境 的 接收 者 如 果 改 “返回 引用 ” 那 么 函数 返回值 是一 个指向 局 部 对 ttmp 的 “引用 ”( 即 地 址 )， 而 temp 在函数 结束 时 被 自动 销毁 将 导致 返回 “引用 ”无效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char * Func(void) " </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span> str[] = <span class="string">"hello world"</span>; /str 数组 创建 在 函数 堆栈 上 ， 并 用 字符 串 / 常量 来 初始 化 在 末尾 自动 添加 ^<span class="number">0</span>” </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">	HA2 <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">end</span>]; </span><br><span class="line">	#<span class="number">11</span> <span class="keyword">return</span> str; / 该 语句 存在 隐患 ，str 指向 的 内 存单 元 将 被 释放 &#125; 但 下 程序 则 是 正确 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="string">"hello world"</span>; / 字符 串 常量 存放 在 程序 的 静态 数据 区</span><br><span class="line">	/ 来 尾 自动 添加 \<span class="number">0'</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; HA</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(p) &lt;&lt; <span class="built_in">endl</span>; HWA</span><br><span class="line">	<span class="keyword">return</span> p; / 返回 字符 串常量 的 地 址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601053851.png" alt=""><br>
“创建 一个 临时 对 并 返回 它 ” 的 过程 是 不 同 的，<strong>编 译 器</strong>可 以 直接 把 临时 对 象 创 建 并初始 化 <strong>外 部 存储 单元</strong> 中 省 了 拷贝 和 析 构 开销 提 高 了 效率</p>
<h3 id="存储类型以及作用域规则"><a class="header-anchor" href="#存储类型以及作用域规则">¶</a>存储类型以及作用域规则</h3>
<h3 id="存储类型"><a class="header-anchor" href="#存储类型">¶</a>存储类型</h3>
<p>extern 、auto 、static、register，</p>
<p>extern 和 static 用 来标识永久 生存 期 限 的 变量 和 函数<br>
而 auto 和 register 则 用 来 标识 临时 生存 期 限 的 变量</p>
<p>全 局 变量 和 全 局 函数 的 存储 类 型 extern 能 够 定义 在 它们之 后 的 同一个 编译 单元 内 的 函数 所 调用<br>
变 量和 函数 显 式 地 加 上 exterm 声明 ，那么 其他 编译 单元 中 的 函数 也 能 调用 它们</p>
<p>显式生命为static的全局变量和全局函数具有static存储类型 只能被同一个编译单元内的函数调用</p>
<p>局 部 变量 默认 具有 auto 存储 类 型 除 非 static 或 register 来 定义<br>
它们 的作用 域 是程序 块作用 域 连 接 类 型 都 内 连接 在 进入 函数 的 时候 创建 ，在 函数退出 的时 候 销毁<br>
register 和 auto 只 能 用 于 声明 局 部 变量 和 局 部 常量</p>
<p>全局常量默认 存储类型 static<br>
除非在定义了它的编译单元之外的其他编译单元中 显式的用extern声明 否则不能被访问<br>
（就是拿过来用的时候 加个extern 声明一下）</p>
<p>局 部 符号 常量 (注意 不是 函数 内 出 现 的 字面 常量 ) 的 默认 存储 类 型 auto，<br>
除非 显式 地 定义 static 或 register.</p>
<p>把 那些 经 常 用 的 变量 例如 循环 计数 器 直接 放 到 CPU 寄存 器 ， 可 以避免 在 寄存 和 内 存 之 间 频 地 交换 数据 因 此 能 提高 程序 的 运行 效率</p>
<h3 id="作用域规则"><a class="header-anchor" href="#作用域规则">¶</a>作用域规则</h3>
<p>在 标准 C 语言 ， 这 些 范围包括 文件 函 数 程 序 和 函数 原型</p>
<p>标准 C++中 除了 这 4 种 外 有 两 作用 域 类 型 类 和 名 字 空 间 其 中 名 字 空 间 是 可 以 跨 文 件 +</p>
<p>S (label) 是 具有 函数 作用 域 的 惟一 一 种 标识 符 这 就 是 说 不 论 你 的 标号定义 在 函数 中 的 哪 一行 ， 也 不 论 定义 在 函数 内 撕套得 多 么 深 的 程序 块 内 它 都能够在 函数 体内 任何 一 个地 方 访问 , 因此 也 叫做 函数 级 的 标识 。 标号 一 般 用 在 goto| 语句 ， 如 果 goto 语句 没有 使 用 到 该 标号 那 么 该 标号 将 忽略</p>
<p>即 使部 变量 的 存储 类 型 声明 static， 它 仍然 具有 程序 作 用</p>
<p>在 函数 中 毁套 的 程序 块 可 以 定义相同 名 字 的 变量 在 内 层 的 变量 玫 蔽外 层 的 同名 变量<br>
当局 部 变量 与 某一 个全 局 变量 同名 ， 在 函数 内 部将史 蔽 全 局 变量<br>
如 果 某 一 个 员 函 数 内 定义 了 与 类 的 某 一 个 数据员 同 名 的 局部 变量 ， 那么 这个 局 部 变量 将 遮蔽 该 同名 数据 成 。</p>
<p>如果 一 个 标识 符 能 够 在 其他 编译 单元 中 或 者 在 定义 它 的 编译单元 中 的 其 他 范围内 被 调用 ， 那 么 它 就 外 连接 的 外 连接 的 标识 符 需要 分 配 运行 时 的 存储 空间</p>
<p>如 果 一 个标识符 能 在 定义 它 的 编译单元 中 的 其他 范围 内 被 调用 但 是 不 能 在他 编译 单元 中 被 调用 那 么 它 就 内 连接</p>
<p>一个仅 能 够 在 声明 它 的 范围 内 被 调用 的名 字 是 无 连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f0</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a; /a 是 连接 的</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span> ... &#125;; / 局 部 类 是 连接 的 具 有 程序 作用 域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601062801.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601062725.png" alt=""></p>
<p>对 ADT/UDT 的 输入 参数 应该 “ 值 传递 改 “const 公 传 递 &quot;， 目的 提高 效率 例 如 ， 将 void Func(Aa) 7H void Func(const A &amp;a).<br>
对 于 基本 数据 类 型 的 输入 参数 不 要 “ 值 传递 ”的 方式 改 “const 信传递 &quot;， 否 则 既 达 不 到 提高 效率 的 目的 又让 人 费解<br>
例如， 不 要<br>
void Func(const int x) 改 void Func(const int 人 x)。</p>
<h3 id="const"><a class="header-anchor" href="#const">¶</a>const</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(constA &amp;a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> pStr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span> *strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = GetString();</span><br></pre></td></tr></table></figure>
<h2 id="4-指针-数组-字符串"><a class="header-anchor" href="#4-指针-数组-字符串">¶</a>4. 指针 数组 字符串</h2>
<p>int* a,b,c; 《=》int <code>*a</code>, b,c;</p>
<p>取 地 址 〈&amp;) 和 反 引 用 〈(<code>*</code>)。</p>
<p>准确的说，与 编译器的目标平台 有关。<br>
如果目标平台是32位的，那么sizeof (void*)就是<strong>4</strong>，<br>
如果是64位的，那么sizeof就是8，<br>
如果是16位的，就是2。 sizeof (void*)的含义就是获取一个指针的大小。<br>
指针的本质就是内存地址，因此指针的大小和内存空间有关。<br>
32位的机器内存空间是2G（windows系统），<br>
因此指针的大小必须是 log_2 (2times 1024^3) = 31 ，凑个整数那就是32bit。</p>
<h3 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h3>
<p>在 语义 上 ， 下 标 操作 符返 回 的 是一 个 元 素 的 引用 。a[3] = 100;<br>
编译器 计算地 址 a + 3 * sizeof (inb， 得 到 0x004284FC， 并 返回 地 址 所 指 对的 引用 而不是 返回 “45” 这 个<br>
a[3] = 100; / 转换 为 *a+ 3) = 100;<br>
cout &lt;&lt; a[3] &lt;&lt; endl， / 转换 cout &lt;&lt; *(a + 3) &lt;&lt; endj;</p>
<p>组 名 字本 身 是 一 个 指针 ， 是 一 个 指针 常量 即 a 等价 int * const a，<br>
因 此你 不 能 试图 修改 数组 名 的 值</p>
<p>a == &amp;a[0]</p>
<p>int a[10] = {0};<br>
int b[10] ={1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>
a=b; /不仅语义 不 对 何 a 也 不 能 被修改</p>
<p>int b[100]; / sizeoftb) = 400 bytes， 未初始<br>
int c[ ]= {1, 2,3, 4,5}; I FBP RA S, sizeof© =20 bytes, 初 始<br>
int d[5] = {1, 2, 3, 4,5, 6, 7}; / 错误 ! 初始 值 越界<br>
int e[10] = {5, 6, 7, 8, 9}; / 元 素 个 数 10， 指 了 前 5 个 元 素 的初始 值 剩<br>
VW 下 的 元 素全 部 自动 初始 化 0<br>
int [10] = {5, 12,2}; / 错误 ! 不 能 跳 过 中 间 的 某些 元 素</p>
<p>C++/C 可 以 在 运行 时 进行 数组 的 越界 访问 检查<br>
这 是 因为 数组 大小 的 信息 保存 在程序 中 的 某 地 方 一 般<br>
就 是 放 在 数组 第 一 个元 素 位 置 的 <strong>前 面</strong> 占用 一 int 变量 的 字节数 ,<br>
它 地 址 a-sizeof(int)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] &lt;&gt; <span class="keyword">int</span>* <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">4</span>] &lt;&gt; <span class="keyword">int</span> (* <span class="keyword">const</span> b)[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] &lt;&gt; <span class="keyword">int</span> (* <span class="keyword">const</span> c)[<span class="number">4</span>][<span class="number">5</span>]:</span><br></pre></td></tr></table></figure>
<p>数组 是 不 能 从 函数 return 语句 返回<br>
数组 可 以作为 函数 的 参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[ ], <span class="keyword">int</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 是 4 而 不 400</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">100</span>] = &#123; <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(x) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 400</span></span><br><span class="line">output( x, <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[ ][<span class="number">20</span>], <span class="keyword">int</span> <span class="built_in">line</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">line</span>; i++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; | &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>][<span class="number">20</span>] = &#123; &#123; <span class="number">100</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(x) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 800</span></span><br><span class="line">output( x, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[ ][<span class="number">20</span>], <span class="keyword">int</span> <span class="built_in">line</span>)</span></span></span><br><span class="line"><span class="function"><span class="built_in">cout</span> &lt;&lt; <span class="title">sizeof</span><span class="params">(a)</span> &lt;&lt; <span class="built_in">endl</span></span>; <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">line</span>; i++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; | &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// a 是 一 个 指向 一 维 数组 的 指针a+l 就 是 指向 二 行 的 指针</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>][<span class="number">20</span>] = &#123; &#123; <span class="number">100</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(x) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 800</span></span><br><span class="line">output( x, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> (*a)j[<span class="number">20</span>], <span class="keyword">int</span> <span class="built_in">line</span>)</span> </span></span><br><span class="line"> a[i][j] 访问转换为 *(a + (i * 20 + j) * sizeof(int)).</span><br></pre></td></tr></table></figure>
<p>char *p = new char[1025]; / 分 配 空间<br>
delete []p; / 删除 数组 空间</p>
<p>它 不 会删除 不 属于 它 内 存单 元 也不 会 泄漏 哪怕 是 一 字 节 的 内 存单 元<br>
因为你 明白 地 告诉 了 编译 : 这 是 在 释放 一 个 字符 数组 ,<br>
“ 请 ” 它 去 p 指向 的 字符 数组 大小 信息 《数组 的 元 素 个 数 它 被 编译 器 保存 在 程序 的 某 个 地 方 )，<br>
然 后 按照 这 个 大 小 来 释放 动态 内 存 这 就 是 数组 的 释放 (delete[]) 的语义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p3)[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>][<span class="number">4</span>]; /OK! 退化 第 一 维 语 义 等</span><br><span class="line"><span class="keyword">int</span> (*p4)[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>]; /OK! 退化 第 一 维 语 义 等</span><br><span class="line"><span class="keyword">char</span> (*p5)[<span class="number">5</span>][<span class="number">7</span>] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>][<span class="number">5</span>][<span class="number">7</span>]; OK! 退化 第 一 维 语 义 等 价</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [jp3; <span class="comment">// 删除 p3</span></span><br><span class="line"><span class="keyword">delete</span> []p4; <span class="comment">// 删除 p4</span></span><br><span class="line"><span class="keyword">delete</span> []p5; <span class="comment">// 删除 p5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char arrChar_1[ ] = &#123;'a’,’b',\0','d',’e"&#125;;</span><br><span class="line"><span class="keyword">char</span> arrChar_2[ ] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = “hello”;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arrChar_1) &lt;&lt; <span class="built_in">endl</span>; /S$， 表 示该 数组 $ 字 节</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(arrChar <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="number">2</span>， 表示 字符 串 长 度 <span class="number">2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arrChar_2) &lt;&lt; <span class="built_in">endl</span>; /<span class="number">6</span>， 表 示 数 组 <span class="number">6</span> 字节</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(arrChar_2) &lt;&lt; <span class="built_in">endl</span>; WS, RARER BREA <span class="number">5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; / <span class="number">4</span>， 表示 指针 p 占 <span class="number">4</span> 字 节</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(p) &lt;&lt; <span class="built_in">endl</span>; /<span class="number">5</span>， 表 示字符 串 长 度 $</span><br><span class="line"></span><br><span class="line">默认 <span class="keyword">char</span> * 表 示 字 符 。 例 如 :</span><br><span class="line">char ch ='a’; / 用 字符 'a来 初始 化 字符变量 ch</span><br><span class="line"><span class="keyword">char</span> *pChar = &amp;ch; / 字符 指针 指向 字符变量</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pChar &lt;&lt; endi; / 错 把 字符 指针 当做 字符 串</span><br><span class="line">正确 用 法 :</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pChar &lt;&lt; <span class="built_in">endl</span>; / 取 一 个 字符</span><br></pre></td></tr></table></figure>
<p>某 些 字符 串 函 数 并 不 会 自动 目标 字符 串 结 尾 追 加 ‘\0’，<br>
例 如 strncpy和 strncat， 除 非你指定 于 值 比 源 串 的 长 度 大1<br>
strcpy 和 strcat 会 把 源串 的 结束 符 一 并 拷贝 到 目标串 中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> _cdecl (* FuncPtr)( <span class="keyword">const</span> <span class="keyword">char</span>*); / 定义 一 种 函数 指针 类</span><br><span class="line">FuncPtr fp_1= <span class="built_in">strlen</span> ;</span><br><span class="line">FuncPtr fp_2 = <span class="built_in">puts</span> ;</span><br><span class="line"><span class="keyword">double</span> _cdecl (*fp_3)( <span class="keyword">double</span> ) = <span class="built_in">sqrt</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = fp_1(‘I am a software engineer.”) ;</span><br><span class="line"><span class="keyword">double</span> d = ( *fp_3 )( <span class="number">10.25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> _cdecl (* fp[<span class="number">5</span>])( <span class="keyword">double</span> ) = &#123; <span class="built_in">sqrt</span>, <span class="built_in">fabs</span>, <span class="built_in">cos</span>, <span class="built_in">sin</span>, <span class="built_in">exp</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (intk = <span class="number">0</span>;k &lt;<span class="number">5</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result :"</span> &lt;&lt; fp[k]( <span class="number">10.25</span> )&lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般 的 函数 调用 语句 可 以 在 编译 时 就 完成 这 个 绑 定《叫做 静态 决议 或 静态 连接 )<br>
运行 时 连接</p>
<p>类 的 员 函 有 4 种 类 型 inline、virtual、static、normal。</p>
<p>inline 函数 在 运行 时会 展开 ， 虽 然 语 言 允许 取 其 地 址 但 是 没有 太 大 意义 。virtual 成 员 函 数 的 地 址 指 的其 vtable 中 的 位 置 ，<br>
static成员 函 数 的 地 和 普通 全 局 函数 的 地 址 没有 任何 区 别 ;<br>
普通 成 员 函 数 的 地 和 一 般 函 数 的 地 址 也 没有 区 别<br>
就 是 函数 代码 在 内 存 中 的 真实地址，<br>
但 是 由 于它 的 调用 要绑 定到 一个 实 实在 在 的 对 象 ，<br>
因 此无 论 是其 函数 指针的 声明 方式 还 是 其 地 址 的 获取 方法 都 比较 特别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">7</span><span class="number">-14</span>。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTest::f0"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; / 普通 员 函</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTest::2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; <span class="comment">// HAR RA</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CTest::hQ)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; /W 虚拟 员 函</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">///...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GFPtr)</span><span class="params">( <span class="keyword">void</span> )</span></span>; / 定义 一 个全局 函数 指针 类</span><br><span class="line">	GFPtr fp = CTest::g ; </span><br><span class="line">										</span><br><span class="line">	fp();                </span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(CTest::*MemFuncPtr)</span><span class="params">( <span class="keyword">void</span>)</span></span>; <span class="comment">// 声明 类 成 员 函 数 指针 类</span></span><br><span class="line">	MemFuncPtr mfp_] = &amp;CTest::f; <span class="comment">// 声明 成 员 函 数 指 针 变 并 初始</span></span><br><span class="line">	MemFuncPtr mfp2 = &amp;CTest::h; / /注意 获取 成 员 函 数 地 址 的 方法</span><br><span class="line">	CTest theObj ;</span><br><span class="line">	(theObj .*mfp_1)() ; / 使 用 对 和 成 员 函 数 指 针 调 用 成 员 函</span><br><span class="line">	(theObj .*mfp_2)() ;</span><br><span class="line">	CTest *pTest = &amp;theObj ;</span><br><span class="line">	(pTest-&gt;*mfp_1)(); / 使 用 对象 指针 和 成 员 函 数 指针 调用 成 员 函</span><br><span class="line">	(pTest-&gt;*mfp_2)() ;</span><br><span class="line">&#125;</span><br><span class="line">输出 结果 </span><br><span class="line">CTest::g()</span><br><span class="line">CTest::f0</span><br><span class="line">CTest::hO</span><br><span class="line">CTest::f0</span><br><span class="line">CTest::h()</span><br></pre></td></tr></table></figure>
<p>为 了 与 静态 员 函数 区 别<br>
取 virtual 函数 和 普通 员 函 数 的 地 址 需要 使用 “&amp;” 运 算<br>
〈 取 静态 成 员 函 数 地址 也 可 以 使 用 它 但 是 没有 必要 )。</p>
<p>由 于 纯 虚 函数 没有 实现 体 而 非纯 虚 函 有 实现 体<br>
且 虚 函数 都是 通过 vptr 和 vtable 来 间接 调用 的<br>
因 此 取 虚 函数 的 地 址 将 得 到该虚 函 数 实现体 vtable 中 的 索引号<br>
要 想得到 虚 函 数 实现 体 的 真实 地 址 ,还需要 首先 从 对 象入手 ，<br>
找到 vptr 的 位 置 进 而 找到 vtable 的 所 在<br>
然 后 根据 函数 指针 的 大 和虚 函 数 的索引 ， 取 出 虚 函 数 的 真实 地 址</p>
<h3 id="引用与指针"><a class="header-anchor" href="#引用与指针">¶</a>引用与指针</h3>
<p>int m;<br>
int&amp; n=m;<br>
n 既 不 是m 的 拷贝 也 不 是指向 m 的指针 ， 其实n 就 m 自己</p>
<p>引用 在 创建 的 同时 必须初始 化 即 引用 到 一个 有 效 对象</p>
<p>const int&amp; rint = 0;</p>
<p>创建 一 个 临时 的 int 对象 用 0 来 初始它 然 后 再 用 它 来 初始 化 引用 rint，<br>
而 该 临时 对 象 将 一 直 保 到 rint 销毁 的 时 候 才 会 销毁。<br>
所以，不 要 用 字面 常量 来 初始化引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给 引用 赋值 并 不 是 改变 和 原始 对 象 的 绑 定 关系</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,b= <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; rInt =a; /rint 引用 到 a，rInt 等 <span class="number">10</span></span><br><span class="line">rInt = b; <span class="comment">// rInt Al a 都 变 成 1000</span></span><br></pre></td></tr></table></figure>
<p>引用 的 创建 和 销毁 并 不 会 调用 类 的 拷贝 构造 函数 和 析构 函 数<br>
在 语言 层面 引 用 的 用 和对 象 一 样<br>
在 二 进 制 层面 引 用 一 般 都 是 通过指针 来 实现 的 只 不过 编译 帮 我 们 完成 了 转换</p>
<p>引 用 的 主要 用 途修饰 函数 的 形参 和 返回 值</p>
<h2 id="5-第八章-C-c高级数据类型"><a class="header-anchor" href="#5-第八章-C-c高级数据类型">¶</a>5. 第八章 C++/c高级数据类型</h2>
<p>C 语言 stuct， 有 时 也 称 用户 自 定义 数据 类 (User defined Type, UDT)。<br>
抽象 数据 类 型 (Abstract Data Type, ADT)，<br>
在 C++ 环境 ， 我 们 把 C 风格 struct 叫做 POD (Plain Old Data) 对象</p>
<p>structyclass 当做 参数 传递 给 函数 ， 默 认为 值 传 递 其 中的 数组 将 全 部 拷贝 到 函数 堆栈<br>
当 你 UDTADT 中 包含 数组 员 的 时 候 最 好使 指针 或 引用传递该 类 型 对 象<br>
并 且 一 定 要 防 让 数组 元 素 越界 否 则 它 覆盖 后的 结构成 员</p>
<p>memset (&amp;s, 0x00, sizeof (Student))<br>
// 可 以 仅指 定 第 一成 员 的初 值 来初始 POD 对 象 后面 的 员 将 全 部 自动初始 化 为0， 就 数组 的始 化 一样<br>
Student s = {0};</p>
<p>一</p>
<p>对 象 间 的 包含 指 一 类 型 对 象 充当 了 另 一 个 类 型 定义 的 数据 成 ，:从 而 也 就 充当 了 它 的 对 象 的 成 ， 即 两 对 象 间 存 has-a 关系<br>
虽然 对 象 不 能 自 包含 但 可 以 自 引用 ， 而 且 两 个 类 型 可 以 交叉 引用 ， 这种 关系称 holds-a 关系<br>
| 个 对 象 不能 自 包含 无 论 是 直接 的 还 间接 的 因 为 编译 器 无法 为 计算 sizeof 值 ， 也 就 不 知道 给这 样 对 象 分 配 多 少 存储 空间<br>
<img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601161745.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601161855.png" alt=""></p>
<p>而 于对 齐 〈 将 大 小 调整 到 机器 字 的 整数<br>
) 的 考虑 每 对 象 的 存储 空间 中 可 能 会 存在 填补 字 节 ， 这 些 字 节 单元 不 会 初始<br>
化 而 具有 上 次 用 留 下 “ 脏 值 ”( 随 机 值 )。 显 然 每 对 象填补 字节 的 内 容 是<br>
,会 相同 的 这就是 说 如 果编译 器 支持使用 逐 位 比较 的默认 方法 来 比较同类型 对象<br>
结果 肯 定 是 不 对</p>
<h3 id="位域"><a class="header-anchor" href="#位域">¶</a>位域</h3>
<p>C 语言 位 各成 员 的 类 型 必须 int、unsigned int、signed int 等 类 型 ，C++ 还 允 许 使 char、long 等 类 型<br>
不 允许 用 指针 类 型 或 浮 点 类 型 作为 位 域 的 成 员 类 ，| 因为 它们 可 能 导致 无效 的 值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateTime</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> year ;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> month :<span class="number">4</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> day  :<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> hour  :<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> minute : <span class="number">6</span>;</span><br><span class="line"><span class="number">6u</span>nsigned <span class="keyword">int</span> second : <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> (DateTime) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>可 以 定义 非 具 名 的 位 域 成 ， 其 作用 是 相当 于 占 位 符 可 用 来 隔离 两 相 邻 的<br>
位 域 成 。 如 示例 8-7， 由 于 第 二 个 位 域 员 没有 名 字 ， 因 此 不 能 直接访问 它 所 在 的位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct DateTime</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">	unsigned int day :5;</span><br><span class="line">	unsigned int :2</span><br><span class="line">	unsigned int hour :5;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可 以 定义 长 度 0 的 位 域 成 ， 其作用是 迫使 下一 个 员 从 下 一 个 完整 机 器 字 〈Word) 开始 分 配 空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DateTime</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> day <span class="number">25</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> :<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hour <span class="number">255</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(DateTime) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>即使位 域 有 成 员 的位 数总 和 达 不 到 整 字 节 的倍数 位 对 象 也会 对 齐 到 机 器 字 长<br>
不 能使 用 访问 数组 元 素 的 方法(<code>[]</code>) 来访问位 域 员 的 单个 位<br>
如 果 有 这 种 需要 ， 请使 用 位运算 (~、区 、|、&gt;&gt;、&lt;&lt;、^ 及 其 = 的组 合 运算 ) 或 者使 <code>std::bitset&lt;N&gt;。</code></p>
<h3 id="成员对齐"><a class="header-anchor" href="#成员对齐">¶</a>成员对齐</h3>
<p>对 于 复合 类 〈 一 般 指 结构 和 类 ) 的 对 象 如 果 它 的 起 始 地 址 能 够 满足 其 中 要求 最 严格 〈 或 最 高 的 那个 数据 员 的 自然 对齐 要 求 那 么 它 就 是 自然 对 齐 的<br>
如果 那 个 数据 员 又 是一 个 复合 类 型 对 象 则 依次 类 推 直 到 最 后 都 基本 类 型数据 成 员</p>
<p>在 C++/C 的 基本数据 类 型 中 如 果 不 考虑 enum 可 能 的 大 值 所 需 的 内 存 字节 数 ，double 就 对 齐 要 求最 严格 的 类 型 ， 其 次 int 和 float， 然 后 short、bool 和 char。</p>
<p>直接 依照 声明 顺序 来 存放 ， 即 复合 类 型 中 存在 多 个 访问 〈 即 C++ 类 中 的 每public. private 和 protected 访问 限定 )， 至 少 也 会 保证 每 个 内 的 有 数据 员 是| 按照 声明 顺序 来 存放</p>
<p>至 于 先 声明 的 员 会 放 在 地 址 还 是 低地 址 处 完 全 是由 编译 器 实现 来 决定 的 而且 – 般 都 采用 “按照 声明 的 先后 顺序 从 低地 址 到 高 地址 依次 放 各 个 成 ” 的 方案</p>
<p>为了对象数组 要实现自然对齐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"><span class="keyword">enum</span> Color&#123; RED = <span class="number">0x01</span>, BLUE, GREEN, YELLOW, BLACK&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sedan</span> // 私家 车</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">bool</span> m_hasSkylight; RRARS</span><br><span class="line">	Color m_color; / 颜色</span><br><span class="line">	beol m_isAutoShift; / 是 否 是 自动 档</span><br><span class="line">	<span class="keyword">double</span> m_price; / 价格 〈 元 )</span><br><span class="line">	BYTE m_seatNum， / 座位数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601165034.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230601165745.png" alt=""></p>
<p>使 offsetof 宏 这 个 宏 专 门 用 来计算 数据 员 相 对 于 对 象 起始地址 的 真实 含 移 量 它 会 把 有 隐 含 员 也 计算 进去 比 如庶 函 表 指针vptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offsetof(Sedan, m_hasSkylight) =” &lt;&lt; offsetof(Sedan, m_hasSkylight) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offsetof(Sedan, m_color) = ” &lt;&lt; offsetof(Sedan, m_color) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offsetof(Sedan, m_isAutoShift) = ” &lt;&lt; offsetof(Sedan, m_isAutoShift) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offsetof(Sedan, m_price) =” &lt;&lt;&lt; offsetof(Sedan, m_price) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offsetof(Sedan, m_seatNum) = ” &lt;&lt; offsetof(Sedan, m_seatNum) ;</span><br></pre></td></tr></table></figure>
<p>编 译器 不 会 随便 地 在 任意 一 个 逻辑 内 存 地址 上来 创建 C++/C的 变量 和 对 象<br>
它们 在内 存 中 的 起 地 址 需要 满足 一 定 的 条 件 数 据 成 员 也 并 一 定 是 挨 在一起 的<br>
而且每个 数据 员 的 地 址 也 不是 随便 安排 的 都 需要 经 过 编译器的 精心 规划 和 计算<br>
这 才能提高 对 及 其 员 的 访问 效率</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sedan s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “Address of s =” &lt;&lt; (<span class="keyword">void</span>* )&amp;s ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offset of m_hasSkylight =” &lt;&lt; ((<span class="keyword">char</span>*)&amp;s.m_hasSkylight — (<span class="keyword">char</span>*)&amp;s) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offset of m_color = ” &lt;&lt; ((<span class="keyword">char</span>*)&amp;s.m_color — (<span class="keyword">char</span>*)&amp;s) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offset of m_isAutoShift =” &lt;&lt; ((<span class="keyword">char</span>*)&amp;s.m_isAutoShift — (<span class="keyword">char</span>*)&amp;s) ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offset of m_price =” &lt;&lt; ((<span class="keyword">char</span>*)&amp;s.m_price — (<span class="keyword">char</span>*)&amp;s);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; “offset of m_seatNum = ” &lt;&lt; ((<span class="keyword">char</span>*)&amp;s.m_seatNum — (<span class="keyword">char</span>*)&amp;s);</span><br></pre></td></tr></table></figure>
<p>综上 所 述 类 的 数据 成 员 类 型 的 选择 声 明 顺 序 即 排列 采 用 的 员 对 齐 方式<br>
都 将影响对 象 的 实际 大小 和 访问 效率</p>
<h3 id="联合-union"><a class="header-anchor" href="#联合-union">¶</a>联合 union</h3>
<p>联合 的 另 一 个 妙用 就 用 来 解析 一 个 寄存 器 或 多 字 节 内 存 变量 的 高 字 节 的 值<br>
而 不 需要 我 们 手工 用 位 运算 符 来 解析 它们 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> KeyCode</span><br><span class="line">&#123;</span><br><span class="line">	short keyNum ;</span><br><span class="line">	<span class="keyword">char</span> byteArr[<span class="number">2</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举"><a class="header-anchor" href="#枚举">¶</a>枚举</h3>
<p>枚 举 类 型还 可 以 是 匿名</p>
<h3 id="文件"><a class="header-anchor" href="#文件">¶</a>文件</h3>
<p>文件 控制 块 (FCB) 的 数组</p>
<h2 id="6-第九章-编译预处理"><a class="header-anchor" href="#6-第九章-编译预处理">¶</a>6. 第九章 编译预处理</h2>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; &gt;</span></span></span><br><span class="line">(<span class="number">2</span>) <span class="meta">#Hinclude <span class="string">" "</span></span></span><br></pre></td></tr></table></figure>
<p>第 一 种 形式 一 般 用 来 包含 开发 环境 提供 的 库 头 文件 它 指示 编译 预 处 理 器 开发 环境 设 定 的 搜索 路 中 查找 所 需 的 头 文件<br>
第 二 种 形式 一 般 用 来 包含 自己 编写 的头 文件 它 指示 编译 预处 理 器 首先 在 当前 工作 目录 下 搜索 头 文件 如 果 找 不 到 的 话再 到 开发 环境 设 定 的 路 径 中 去 查找 。</p>
<p>内 部 包含  卫 哨<br>
为了 避免 同一 个 编译 单元 包含 同一 个 头 文件 内 容 超 过 一次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stddef.h</span></span><br><span class="line">#ifndef_STDDEF H INCLUDED_</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STDDEF_H INCLUDED _</span></span><br><span class="line">					/ / 头 文件 内 容</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    /!STDDEF H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “stddef.h”</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “stddef.h” /! No problem!</span></span><br></pre></td></tr></table></figure>
<p>外 部 包含 卫  哨</p>
<p>当 一 个 头 文件 被 一 个源 文件 反 复 包 含 多 次 避免 多 次 查找 和 打开 头 文件 的 操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined ( INCLUDED_STDDEF_H_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INCLUDED_STDDEF_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//!_ INCLUDED _STDDEF_H_</span></span></span><br></pre></td></tr></table></figure>
<p>在 头 文件 中 :<br>
(1) 包含 当前 工程 中 所 需要 的 自 定义 头 文件 〈 顺 序 自 );<br>
(2) 包含 第 三 方程 序库 的 头 文件 ;<br>
(3) 包含标准 头 文件 。<br>
在 源 文 中 :<br>
(1) 包含 源 文件 对 应 的 头 文件 《如 果 存 );<br>
(2) 包含 当前 工程 中 所 需要 的 自 定义 头 文件 ;<br>
(3) 包含 第 三 方程 序 库 的 头 文件 ;<br>
(4) 包含 标准 头 文件</p>
<p>宏 定义 具有 文件作用</p>
<p>宏定义 <code>#define</code> 关键 字 后 出现 的 第一 个 连续字符 序列 作为 宏 名<br>
剩 下 的 部 作为 宏体</p>
<p>宏 不 会 进入 符号<br>
即 宏替换 后 出 了 语法 错误 编 译 器 也 会 将 错误<br>
定位 到 源 程序中<br>
而 不 是 定位 到 具体的 某个 宏 定义</p>
<p>定义 带 参数 的 宏 ， 宏 和 左 括号 之 间 不 能 出 现 空格 否 则 使 用 时 会 出问题<br>
但 是 编译 器 不 检查 出 这 种 错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">OUTPUT</span><span class="params">(<span class="keyword">word</span>)</span> <span class="built_in">cout</span> &lt;&lt; <span class="meta">#word &lt;&lt; endl</span></span></span><br><span class="line"><span class="function"><span class="title">OUTPUTI</span><span class="params">( like swimming very much.)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I like swimming very much."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXT (str)#str</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; TEXT(Hello World);</span><br><span class="line">(str)<span class="meta">#str(Hello World);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PL 2 (2 * PI)</span></span><br><span class="line"></span><br><span class="line">带 参数 的 宏 体 和 各个形 参 应 该 分 别 用 括号 括 起 来</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x)((x) * (x))</span></span><br><span class="line"></span><br><span class="line">不 要 在 引用 宏 定义 的 参数 列表 中 使 用 增 和 减 量 运算 符 否则 将 导致 变量的 多 次 求值</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> x = SQUARE(n++&#125;;</span><br><span class="line"><span class="keyword">int</span> x = ((n++) * (n++));</span><br><span class="line"></span><br><span class="line">其结果 将 <span class="number">30</span> 而 不 是 期 望 <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>用 宏 来 构造 一 些 重复 、 数据 和 函数 混合 的 功 能 较 特 殊 的代码 段 时候 其 优点就显示 出 来 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE DYNAMIC(class_name) \</span></span><br><span class="line"><span class="keyword">protected</span>: \</span><br><span class="line"><span class="keyword">static</span> CRuntimeClass* PASCAL _GetBaseClass(); \</span><br><span class="line"><span class="keyword">public</span>: \</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> AFX_DATA CRuntimeClass <span class="class"><span class="keyword">class</span>##<span class="title">class_name</span>;</span> \</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> CRuntimeClass* <span class="title">GetRuntimeClass</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE _DYNCREATE(class_name) \</span></span><br><span class="line">DECLARE_DYNAMIC(class_name) \</span><br><span class="line"><span class="function"><span class="keyword">static</span> CObject* PASCAL <span class="title">CreateObject</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TEXT</span></span><br></pre></td></tr></table></figure>
<p>不 要 使 用 宏 来 定义 新 类 型 名 应 该 使 typedef， 否则 容易 造成错误<br>
给 宏 加 注释 时 请 使 块 注释 〈<code>/* */</code>)， 而 要 使 用 行 注释</p>
<p>对 于 较 长 的 用 频率 较高 的 重复 代码 片段 建 议 用 函数 或 模板<br>
对 于 较 短 的 重复代码 片段 可 以 用 带 参数 的 宏 定义</p>
<h3 id="条件编译"><a class="header-anchor" href="#条件编译">¶</a>条件编译</h3>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if 0</span></span><br><span class="line">	… / 希望 禁止 编译 的代码</span><br><span class="line">	... / 希望 禁止 编译 的 代码</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>编译 伪 指 <code>#error</code> 用 于 输出 与 平台 、 环 境 有 关 的 信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(WIN32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> ERROR: Only Win32 platform supported!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> MFC requires C++ compilation (use a .cpp suffix)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译伪指令#pragma 用于执行语言实现所定义的动作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pragma <span class="title">pack</span><span class="params">(push, <span class="number">8</span>)</span> <span class="comment">/* 对 象 员 对 齐 字 节数 所</span></span></span><br><span class="line"><span class="function"><span class="comment">#pragma pack(pop)</span></span></span><br><span class="line"><span class="function"><span class="comment">#pragma warning(disable:4069)  /*不要产生C4069警告 */</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"kernel32.lib"</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"user32.lib"</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"gdi32.lib"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>构 串 操作符 # 只 能修饰 带 参数 的 宏 的 形 参 它 将 实 参 的 字符 序列<br>
转换 字符 串 常量<br>
而 不 是 实 参代表 的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING(x) #x #x #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEXT(x) <span class="meta-string">"class"</span> #x <span class="meta-string">"Info"</span></span></span><br></pre></td></tr></table></figure>
<p>合并 操作符 ## 将 出现在 其 左右 的 字符 序列 合并 成 个新 的标识</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS NAME(name) class##name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MERGE(x, y) x##y#x</span></span><br><span class="line"></span><br><span class="line">classSysTimer</span><br><span class="line">meTome</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602074658.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> * <span class="keyword">const</span> pDouble = <span class="keyword">new</span>(nothrow) <span class="keyword">double</span>[ <span class="number">10000000</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>( pDouble == <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"allocate memory failed on line"</span>&lt;&lt;(_ LINE <span class="number">-2</span>)</span><br><span class="line">&lt;&lt; <span class="string">"in file"</span> &lt;&lt; FILE &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-文件结构-程序板式"><a class="header-anchor" href="#C-文件结构-程序板式">¶</a>C++文件结构 程序板式</h3>
<p>头 文件 的 有 内 容 最 终都 会 被 合并 到 某 一 个 或 几 个 源 文件 ，<br>
如 此 将 一 个 包含 的 头 文件 递归 地 展开 后 形成 的 源 文件 叫 编译单元</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">int</span> *x，y; / 此 y 不 会 误解 为 指针</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* PINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>&amp; RINT;</span><br><span class="line">PINT pl, p2; / 两 个 指针</span><br><span class="line">RINT ril=i r2=j; /两 引用</span><br></pre></td></tr></table></figure>
<h3 id="C-命名规则"><a class="header-anchor" href="#C-命名规则">¶</a>C++命名规则</h3>
<h2 id="7-C-面向对象程序设计方法"><a class="header-anchor" href="#7-C-面向对象程序设计方法">¶</a>7. C++面向对象程序设计方法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">继承</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Funcl</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func4</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">B b;</span><br><span class="line">b.Funcl(); </span><br><span class="line">b.Func2();</span><br><span class="line">b.Func3();</span><br><span class="line">b.Func4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ 虚函数，抽象基类， 动态绑定 (Dynamic binding) 多态 (Polymorphism)<br>
构成 了 出 色 的 动态 特性</p>
<p>为 了 使 这 种 行为 可 行 我 们 把基类 Shape 中 的 函数 Draw0O 声 明 为 虚 函 数<br>
然 后在 派生 类 中 重新定义 Draw()<br>
使 之绘制 正确 的 形状 这 种 方法叫覆盖 〈Override)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// Draw() </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">void</span>)</span></span>; / /Draw0O 为 虚 函数 不写<span class="keyword">virtual</span> 也会变成虚函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽 象 类 的唯 – 目 的 是 让 其派生 类 继承 并 实现 它 的 接口 方法 (Method)，<br>
因 此 它 通 也 被 称 为抽象 基 类 〈Abstract Base Class)</p>
<p>如 果 将 基 类 的 虚 函 数 声明 为 纯虚 函数 那 么 类 就 定义 了 抽象 基类 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span> <span class="comment">// Shape 是 抽象 基类</span></span><br><span class="line">ublic:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">void</span>)</span> </span>= <span class="number">0</span>; / Draw(<span class="number">0</span> 为 纯 虚 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一 个 函数初始 化 0 意味 着 函数 地 址 将为 0，<br>
这就是 在 告诉 编译 器 不 要 为 函数 编 址 从 而阻止 类 的 实例 化行为<br>
C++ 中 只 有虚 函 数 才可 以 被 初始 化 0</p>
<p>一般 的 信息 隐藏 是 把类 的 有 数据 员 声 明 private 或 protected 的<br>
并 提供 相应 get set 函数 来 访问 对象 的 数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> [<span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~IRectangle() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetLength</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetLength</span><span class="params">( <span class="keyword">float</span> newLength)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">float</span> GetWidthQ <span class="keyword">const</span> = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetWidth</span><span class="params">(<span class="keyword">float</span> <span class="keyword">new</span> Width)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> RGB <span class="title">GetColor</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span> ; <span class="comment">// RGB : unsigned long</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetColor</span><span class="params">(RGB newColor)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">CalculateArea</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> DrawQ) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> IRectangle* _stdcall CreateRectangleQ; /入 口 函数</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span></span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectangleImpl</span> :</span> <span class="keyword">public</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RectangleImplQ : m_length(<span class="number">1</span>), m_width(<span class="number">1</span>), m_color(OxOOFFEC4D)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~RectangleImpl() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">GetLength</span><span class="params">( <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_length; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> <span class="keyword">void</span> SetLength(<span class="keyword">float</span> newLength) &#123; m_length = newLength; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> <span class="keyword">float</span> GetWidth() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_width; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> <span class="keyword">void</span> SetWidth(<span class="keyword">float</span> newWidth) &#123; m_width = newWidth; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> RGB GetColor() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_color; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> <span class="keyword">void</span> SetColor(RGB newColor) &#123; m_color = newColor; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> <span class="keyword">float</span> CalculateArea() <span class="keyword">const</span> &#123; <span class="keyword">return</span> m_length * m_width; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">virtual</span> <span class="keyword">void</span> +Draw() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RectangleImpl::Draw(Q)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">float</span> m_length;</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">float</span> m_width;</span></span></span><br><span class="line"><span class="function"><span class="params">	RGB mcolor;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;;</span></span></span><br><span class="line"><span class="function"><span class="params">	IRectangle* stdcall IRectangle::CreateRectangleO</span></span></span><br><span class="line"><span class="function"><span class="params">	&#123;Return <span class="keyword">new</span>(nothrow) RectangleImpl;&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>每 一 个 具有 虚 函 数 的 类 都 叫做 多 态 类，<br>
这 个 虚 函 数 或者是 从基 类 继承 来 或者是 自己 新 增加<br>
C++ 编译 器 必须 为 每 一 多 态 类 至 少 创建 一 个 虚 函 数 表 (vtable )，<br>
它 实 就 是一 个 函数 指针 数组<br>
其 中 存放 着这 个类 所 有 的 虚 函 数 的 地 址 及 该 类 的 类、型信息<br>
其 中 也 包括 那些 继承但 未 改写 《Overrides) 的 虚 函 数</p>
<p>每一 个 多 态 对有 一 个 隐 含 的 指针 成 ， 它 指向 所 属 类 型 vtable， 这就 vptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(p-&gt;_vptr[slotNum]))(p, arg-<span class="built_in">list</span>); <span class="comment">// 指针 当 作 数组 来 用 最 后 改写 为 指针 运算</span></span><br></pre></td></tr></table></figure>
<p>派生 类 定义 中 的 名 字 〈 对 象 函数 ) 将 义无反顾 地 遮 项 〈( 即 隐藏 )掉 、<br>
基 类 中 任何 同名 的 对 象 函数</p>
<p>基 于 这 样 的 规则 ， 如 果 派生 类 定义 了 一 个 与 基类 的 虚 函 数 同名 的 虚 函 数<br>
但 是 <strong>参数 列表 有 所 不 同</strong><br>
那 这就 不 会 编译 器 认为 是对 基 类 虚 函 数 的 改写 (Overrides)， 而 是 <strong>隐藏</strong><br>
所 以 也 不 可 能 生 运行 时 绑 定</p>
<p>要 想 达成 运行 时 <strong>绑 定</strong> 的 效果 ，<br>
派 生 类 和 基 类 中 同名 的 虚 函 数 必须 具有 相同 的 原型 ，<br>
也 即 相同 Signature〈 返 回 类 型可 以 不 同 这是 C++ 的 一 个 特征 一 协 变)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IRectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~IRectangle() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectangleImpl</span> :</span> <span class="keyword">public</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RectangleImplQ) : m_length(<span class="number">1</span>), m_width(<span class="number">1</span>), m_color(Ox0OFFEC4D) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~RectangleImpl() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">(<span class="keyword">int</span> scale)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RectangleImpl::Draw(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; <span class="comment">// (1)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"RectangleImpl::Draw()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125; (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> m_length;</span><br><span class="line"><span class="keyword">float</span> m_width;</span><br><span class="line">RGB mcolor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IRectangle *pRect = [Rectangle::CreateRectangle();</span><br><span class="line"><span class="keyword">if</span> (pRect == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">pRect-&gt;Draw(); <span class="comment">// FA-F pRect MatAS2R HW TRectangle*, ATLAH IRectangle::</span></span><br><span class="line">/Draw0 执行 静态 类 型 检查 但 由 pRect 指向 的 对 象实际 是</span><br><span class="line">/&#123; Rectanglelmpl 9, FAM hse Fl Rectanglelmpl::Draw()!</span><br><span class="line">pRect-&gt;Draw(<span class="number">200</span>); /W 同 理 由 于 下 ectangie 类 并 没有 此 类 原型 的 函数 因 此 拒绝</span><br><span class="line">/ 编译 除 pRect 的 类 型 RectangleImpl* 。 此 Draw(<span class="number">0</span>) 非 彼</span><br><span class="line">/DrawgO</span><br><span class="line">pRect-&gt;Destroy();</span><br><span class="line">pRect = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如 果 RectangleImpl 不 重 定义 Draw0O 函 数 那 下 面<br>
代码 ，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RectangleImpl *pRectImpl = <span class="keyword">new</span> RectangleImpli</span><br><span class="line">pRectImpl-&gt;DrawQ); /f (<span class="number">3</span>)</span><br><span class="line">pRectImpl-&gt;Draw(<span class="number">200</span>); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure>
<p>将 无法 编译 因 为 (3) 处 调用 的 Draw0 是 基 类 的 函数 它 RectangleImpl 中 的 同名<br>
| BR Drawn eT, BRT!</p>
<h3 id="运行时多态"><a class="header-anchor" href="#运行时多态">¶</a>运行时多态</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Draw</span><span class="params">(Shape *pShape)</span> <span class="comment">// SAHA</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pShape-&gt;Draw(); / 或 : (*pShapej.Draw();</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">Circle aCircle;</span><br><span class="line">Cube aCube;</span><br><span class="line">Sphere aSphere;</span><br><span class="line">:Draw(&amp;aCircle); <span class="comment">// 绘制 一 circle</span></span><br><span class="line">:Draw(&amp;aCube); /W 绘制 一 cube</span><br><span class="line">:Draw(&amp;aSphere); / 绘制 一 Sphere</span><br></pre></td></tr></table></figure>
<p>RTTI也是一种运行时多态 dynamic_cast&lt;&gt; 和 typeid 运算 符<br>
依赖 RTTI 会 导 致 严重 的 效率 低下</p>
<p>如 果 确 实 需要使 用 多 态 数 组 请使 STL 容器 配合 普通 指针 或者 智能 指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SmartPtr&lt;Shape&gt; ShapeSmartPtr;</span><br><span class="line">ShapeSmartPtr shapes[<span class="number">3</span>];</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">p</span><span class="params">(<span class="keyword">new</span> Shape(Point(<span class="number">1</span>, <span class="number">1</span>)))</span></span>;</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">q</span><span class="params">(<span class="keyword">new</span> Circle(Point(<span class="number">2</span>, <span class="number">2</span>), <span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">r</span><span class="params">(<span class="keyword">new</span> Rectangle(Point(<span class="number">3</span>, <span class="number">3</span>), Point(<span class="number">4</span>, <span class="number">4</span>)))</span></span>;</span><br><span class="line">shapes[<span class="number">0</span>] = p;</span><br><span class="line">shapes[<span class="number">1</span>] = q;</span><br><span class="line">shapes[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1</span> &lt; <span class="number">3</span>; ++i)</span><br><span class="line">shapes[i]-&gt;Draw();</span><br></pre></td></tr></table></figure>
<h3 id="C-对象模型"><a class="header-anchor" href="#C-对象模型">¶</a>C++对象模型</h3>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602093920.png" alt=""></p>
<p>如 果 基 类 已 经 插入 了 vptr， 则 派生 类 将 继承 和 重用 vptr;</p>
<p>如 果 派 生 类 是 从 多 个 基 类 继承 或 有 多 个 继承 分 《从 所 有根类 开始 算起 )，<br>
而 中 若干 个 继承 分 上 出 了 多 态 ，<br>
则 派生 类 将 从 这些 分 中 的每 个 分 上 继承 一 个vptr，<br>
编 译 器 也 将 为 它 生 成 多 个 vtable，<br>
有 几 vptr 就生成 几 个 vtable (每 vptr 分 别 指向 中 一 )，<br>
分 别 与它 的 多 态 基 类 对 应 ;</p>
<p>vptr 在 派生 类 对 象 中 的 相对 位 置 不 会 随 着 继承层次 的 逐渐 加 深 而 改变<br>
并且现在 的 编译 器 一 般 都 vptr 放 在 有 数据 员 的 最 前</p>
<p>为 了 支持 RTTI， 为 一 多 态 类 创建 一 type_info 对 象<br>
并 把 地 址 保存在 vtable 中 的 固定 位</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602094557.png" alt=""></p>
<p>vtable 也 是一 个 函数 指针 数组 按 理 说 也 只 能 存放 类 型 相同 的 函数 指针 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *PVFN)</span><span class="params">(<span class="keyword">void</span>)</span></span>; / 通用 的 虚 函 数 指针 类</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	type_info *_pTypelnfo;</span><br><span class="line">	PVFN _arrayOfPvfn&#123;]; / 虚 函 数 个 数 由初始 化 语句 确定</span><br><span class="line">&#125; VIABLE;</span><br></pre></td></tr></table></figure>
<p>如 果派 生 类 改写 了 基 类 的 虚 函 数<br>
则 这 个 函数 的 地址 在派生 类 vtable 中 的位 置 它 在其 基类 vtable 中 的 位 置 一致<br>
(覆盖)</p>
<p>虚 函 数 第一 次 出现时 它 vtable 中 的 位 置 旦 确定 就 不随 派生 层次 的 增加 而 改变<br>
除 非 改 了 它 和 其 他 虚 函 数 class 中 第 一 次声明 的 顺序</p>
<p>派生 类 没有 改写 基 类 虚 函 数 被 继承 下来并 插入派生 类 vtable 中<br>
(与 该函数 所 在 基 类对 应 下 来 的 那个 vtable)，<br>
且 在 派生 类 vtable 中 的 位 置 其基 类 vtable 中 的 位 相 同</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602102846.png" alt=""></p>
<p>类的 静态 数据 员 可 以 class 的 定义 中 直接 初始 化<br>
但 是要 清楚 : 这 只 是声明并 给 它 提供 了 一 个 初 值 而 已<br>
还 必须 在 某 一 个 编译 单元 中 把 它 定义 一 次〈 即 分 配 内存)。</p>
<h2 id="8-对象的初始化-拷贝-析构"><a class="header-anchor" href="#8-对象的初始化-拷贝-析构">¶</a>8. 对象的初始化 拷贝 析构</h2>
<p>”初始 化 是 在 对 象 创建 的 同时 使 初 直接 填充 对 象 的 内 存单 元 因 此<br>
不 有 数据 类 型 转换 中 间 过 程 也 就 不 会 产生 临时 对 象</p>
<p>赋值 则 是在 对 象 创建 好 后 任何 时 候 可 以 调用 的 而 且 可 以 多 次 调用 的 函数<br>
由 于它 调用 的 “=” 运 算 符<br>
因 此 可 能 需要 进行 类 型 转换 即 会 产生 临时 对象</p>
<p>如果程序员没有为一个多态类显式地定义 默认构造函数 拷贝构造函数 析构函数或拷贝赋值函数<br>
那么 编译 器会 自动 地 生成 相应 的 函数 它 们 都public inline的 ,<br>
并 在 其中 插入 正确 初始 化 或 修改 vptr 数 据 员 值 代码 ，<br>
从 而 确保基 类 对 和 派生 类 对 象 构造 时 及 在 它们 之 间 拷贝时<br>
vptr 能 够向 重新 指向 恰当 的 vtable.<br>
这样 四 个 函数 就 分 别 叫 做<br>
非 平凡 默认 构造函数<br>
非 平凡 拷贝 构造 函数<br>
非 平凡 析 构 函数 和<br>
非 平凡 拷贝 赋值 函数</p>
<p>在 构造 函数 体内 来 初始 化 数据 不 是 真正 意义 上 的初始化 而 是 赋值</p>
<p>由 于 构造 函数 是 创建 一 对象 时 自动 调用 的 第 一 个 成员 函数<br>
因 此 我 们也 愿意 把 构造 函数 体内 的 赋值 语句 当成 初始 化 来 看</p>
<p>真正 的 初始 化 是 用 所 谓 “初始 化表达式表”( 简称 初始 化 列表 ) 进行<br>
初始 化 列表 位 于 构造 函数 参数 表 之 后 在 函数 {} 之 前</p>
<p>如 果 类 存在 继承 关系 派 生类可 以 直接 在其 初始 化 列表 里<br>
调用 基 类 的 特定构造 函数 以 向 它 传递 参数<br>
因 为 我们 不 能 在 初始 化 对 象 时 访问 基 类 的 数据 成 员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x); /A 的 构造 函数</span><br><span class="line">vas B : <span class="keyword">public</span> A &#123;</span><br><span class="line">B(<span class="keyword">int</span> x, <span class="keyword">int</span> y); /B 的 构造函数</span><br><span class="line">Buin x, <span class="keyword">int</span> y) : A(x) / 在 初始 化 列表 里 调用 A 的 构造 函数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 的 非 静 const 数据 成 和 引用 成 员 只 能 在 初始 化 列表 里 初始 化<br>
因 为它们 只 存在 初始 化 语义 而 不 存在 赋值 语义</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> m;</span><br><span class="line"><span class="built_in">int</span> &amp;n=m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A &#123;</span><br><span class="line"><span class="constructor">A(<span class="params">void</span>)</span>; BRA</span><br><span class="line"><span class="constructor">A(<span class="params">const</span> A&amp; <span class="params">other</span>)</span>;<span class="operator"> / </span>拷贝 构造 函数</span><br><span class="line">A&amp; operator =( const A&amp; other);<span class="operator"> / </span>赋值 函数</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line">public:</span><br><span class="line"><span class="constructor">B(<span class="params">const</span> A&amp; <span class="params">a</span>)</span>; /B 的 构造 函数</span><br><span class="line">Private:</span><br><span class="line">A ma;<span class="operator"> / </span>成 员 对</span><br><span class="line">&#125;;</span><br><span class="line">/ (<span class="number">1</span>) 采用 初始 化 列表 的 方式初始</span><br><span class="line">B::<span class="constructor">B(<span class="params">const</span> A&amp; <span class="params">a</span>)</span> : m<span class="constructor">_a(<span class="params">a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 采用 函数 体内 赋值 的 方式 初始</span><br><span class="line">B::<span class="constructor">B(<span class="params">const</span> A&amp; <span class="params">a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">m_a=a; <span class="comment">// 〈 调 了 A 的 默认 构造 函数 )， 再 调用类 A 的 赋值 函数 才 将 参数 a赋 m_a。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 内 部 数据 类 型 的 数据 员 而 言 两 种 初始 化 方式 的 效率 几乎 没有 区别</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">F</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">F(<span class="keyword">int</span> x, <span class="keyword">int</span> y); / 构造 函数</span><br><span class="line">Private:</span><br><span class="line"><span class="keyword">int</span> m_x;</span><br><span class="line"><span class="keyword">int</span> m_y;</span><br><span class="line">&#125;</span><br><span class="line">CL) 采用初始 化 列表 的 方式初始</span><br><span class="line">F::F(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 采用 函数 体内 赋值 的 方式初始</span><br><span class="line">F::F(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">m_x=x;</span><br><span class="line">my=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化顺序序 并不 一 定 与 你在 初始 化 列表 中 为 它们 安排 的 顺序 一 致<br>
编 译 器 总 是按照 它们 在 类 中 <strong>声明 的 次序</strong> 来 初始 化 的<br>
所以最 好 是 按照 它们 的 声明 顺序 书写 员 初 始 化 列表</p>
<p>如 果 各 个 员 的 初始 化 存在依赖 关系<br>
要 注意 顺序 问题<br>
可 以 调整 下 数据员 的 <strong>声明 顺序</strong> 避免 这 个 问题</p>
<p>构造 函数首先 调用每 一 个基类 的 构造 函数<br>
然 后 调用成 员 对 象 的 构造 函数<br>
而 每 一 基类 的构造 函数 又 将 首先 调用 它们 各 自 基类 的 构造 函数 直 到 最 根 。</p>
<p>析 构 会 严格 按照 对 象 构造 相反 的 次 序 执行 该 次 序 是 唯一 的 否 则 编译 器 将 无 法 自动 执行 析 构 过 ;</p>
<p>数据 员 的 初始 化 次 序 完全 不 受 它们 在 初始 化 列表 中 出 现 次 序 的 影响<br>
只由 它们 在 类 中 声明 的 次 序 决 定 因 为 这 个 顺序 是 唯一 的</p>
<p>如 果 数 据 员 按照 初始 化 列表 的次序 进 行 构造 将 导致 析 构 函数 无法得到唯一的逆序。</p>
<p>拷贝 构造 函数 的 参数 必须 是 同类 对 象 的 引用 ， 而 不 能 是 对 象 值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"> 拷贝构造 函数</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">A(A copy)&#123;...&#125; “#Q)陷入 不 地 分 配 堆栈 的 无 限 递归</span><br><span class="line">A(<span class="keyword">const</span> A&amp; other) &#123;...&#125; (<span class="number">2</span>)</span><br><span class="line">MN...</span><br><span class="line">上</span><br><span class="line">Aa;</span><br><span class="line">Ab=a;</span><br></pre></td></tr></table></figure>
<p>不 主 动 编写 拷贝 构造 函数 和 拷贝 赋值 函数 编 译 器<br>
将 “ 按 员 拷贝 ”的 方式 自动 生成 相应 的默认 函数<br>
倘 类 中 含有 指针 员 或 引用 成员 ， 那 这 两 个默认 的 函数 可 能 隐 含错误</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602112452.png" alt=""></p>
<p>拷贝 构造 函数 是在对 象 被 创建 并 用 另 一 个 已 经 存在 的 对 象 来 初始 化 它 时 调用<br>
赋值函数只能把一个对象 赋值 给 另 一 个 已 经 存在 的 对 象<br>
使 得 经 存在 的 对 象 有 和 源 对 象 相同 的 状态 。</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602112740.png" alt=""></p>
<p>只 需 将 拷贝 构造 函数 和 拷贝 赋值 函数 声明 private， 并 且 不 实现 它们<br>
显 式 声明 的 这两 个函数 会 阻止 编译 器 自动 生成 相应 的 默认 函数</p>
<p>甚至 可 以 把 类 的 有 构造 函数 和 赋值函数 都 声明 为 private，<br>
这 样 就 彻底 阻止 了类 的 实例 化</p>
<p>或 者 把 默认 构造 函数 声明为 private，<br>
而 把 其 他 带 参 数 的 构造 函数明 public，<br>
这 样 强 用 户 使 用 带 参数 的 构造 函数 来 声明 和 定义 对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">fe.</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">GetType</span><span class="params">()</span></span>; / 未 实现</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">A(<span class="keyword">const</span> A&amp; a); / 私有 的 拷贝 构造 函数</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp; a); / 私有 的 拷贝 赋值 函数</span><br><span class="line">is</span><br><span class="line">如 果 有 人 试图 编写 如下 程序 :</span><br><span class="line">A ba); UBF T AAA See DFE</span><br><span class="line">b=a; / 调用 了 私有 的 赋值 函数</span><br></pre></td></tr></table></figure>
<p>派生 类 的 构造函数 应 在其 初始 化 列表 里显式 地 调用 基 类 的 构造 函数</p>
<p>如 果 基 类 是 多 态 ， 那 么 必须 把 基 类 的 析 构 函数 定义 为 虚 函 数<br>
这 样 可以 其 他虚 函 数 一 实现 动态 绑 定 否则 有可 能 造成 内 存 泄漏<br>
delete 基类指针 不会释放派生类</p>
<p>基关 的 构造函数 、 析 构 函 数 赋信函 数都 不 能被 派生 类 继承<br>
<img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602114921.png" alt=""></p>
<h2 id="9-C-函数-高级特性"><a class="header-anchor" href="#9-C-函数-高级特性">¶</a>9. C++函数 高级特性</h2>
<h3 id="重载"><a class="header-anchor" href="#重载">¶</a>重载</h3>
<p>编译 器 根据 参数列表 为 个 重 载 函 数 产生 不 同的 内 部 标识 符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> _cdeci <span class="title">foo</span><span class="params">(intx, inty)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该 函数 被 C 编译 器 编译 后 在 库 中 的 名 字 为 foo，<br>
而 C++ 编译 器 则 会 产生 像 | <code>_foo_int_int</code> 之 类 的 内 部 名 字 用 来 支持 函数 重 载<br>
由 于 编译 后 的 名 字 不 同 ，C++ 程 序 | 不能 直接 调用 编译 后 C 函数 。<br>
C++ 提 供 了 一 C 连接交换 指示 符 extern “C” 来 解决 这 个 问题</p>
<p>这就 是连接 规范 的 概念</p>
<p>上 述代码 是 在 告诉 C++ 编译 器 函 foo 是 C 连接<br>
函数 应 该 为 生成 名 字 <code>_foo</code> 而 不 <code>_foo_int_int</code>，<br>
并 指示连接 器 到 C 程序 库 中 去 找该函数 的 定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">( intx )</span></span>; / 函数 声明</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">( <span class="keyword">float</span> x )</span></span>; / 函数 声明</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">( <span class="keyword">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">" output int "</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">( <span class="keyword">float</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">" output float "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> y = <span class="number">1.0</span>;</span><br><span class="line">output(x); <span class="comment">// output int1</span></span><br><span class="line">output(y); <span class="comment">// output float 1</span></span><br><span class="line">output(<span class="number">1</span>); <span class="comment">// output int 1</span></span><br><span class="line">output(<span class="number">0.5</span>); / 错误 ! 不 明确 的 调用 ， 因 为 自动 类 型 转换</span><br><span class="line">output(<span class="keyword">int</span>(<span class="number">0.5</span>)); <span class="comment">// output int 0</span></span><br><span class="line">output(<span class="keyword">float</span>(<span class="number">0.5</span>)); /f output <span class="keyword">float</span> <span class="number">0.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数的重载-覆盖与隐藏"><a class="header-anchor" href="#成员函数的重载-覆盖与隐藏">¶</a>成员函数的重载 覆盖与隐藏</h3>
<p>成 员 函 数被<strong>重载</strong> 的 特征 ：<br>
具 有 相同 作用域 〈 即 同一 个 类 定义 );<br>
函数名字相同<br>
参数 类 型 顺序 或数目 不 同〈 包 const 参数 和 非 const 参数 );<br>
virtual 关键字 可有可无</p>
<p><strong>履 盖</strong> 是 指派 生 类 重新 实现 〈 或 者 改写 了 基 类 的 员 函 数 其 特征 :<br>
不 同 的作用域 〈 分 别 于派生 类 和 基 类 中 );<br>
函数名称相同<br>
参 数列 表完 全 相同 ;<br>
基 类 函数 必须 是 虚 函 数 <strong>只能覆盖 同名同参 虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f(int) "</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f(float) "</span>&lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g(void)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">b</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “Derived::g(<span class="keyword">void</span>)<span class="string">" &lt;&lt; endl; &#125;</span></span><br><span class="line"><span class="string">上</span></span><br><span class="line"><span class="string">void main(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">Derived d;</span></span><br><span class="line"><span class="string">Base *pb = &amp;d;</span></span><br><span class="line"><span class="string">| pb—&gt;f(42); // Base::f(int) 42</span></span><br><span class="line"><span class="string">pb 一 &gt;f3.140; ——_‘// Base::f(float) 3.14</span></span><br><span class="line"><span class="string">pb 一 &gt;gO; / Derived::g(void)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>函数 Base::fint) Base::f(float)构成重载<br>
Base::g(void) 被 Derived::g(void) 覆盖</p>
<p>虚 函 数 的 覆盖 有 两 种 方式 : 完全 重 和 扩展 。<br>
扩展 是 指派 生 类 诬 数 首先 调用 基 类的 虚 函 数 然 后 再 增加 新 的 功能 。</p>
<p>“隐藏 ”是 指派 生 类 的 员 函 数 遮 了 与 其 同名 的 基 类 成 员 函 数：</p>
<ol>
<li>派 生 类 的 函数 基类 的 函数 同名 ， 但 是 <strong>参数 列表 有所 差异</strong><br>
不轮 有无 virtual 关键 ， 基 类 的 函数 在 派生 类 中 将 隐藏</li>
<li>派生类的函数与基类的函数同名，<strong>参 数列表也相同</strong> 但 基类函数 没有virtual 关键字。<br>
此 时 , 基类的函数在派生类中将隐藏 (注意 别 与 覆盖 混淆 )。</li>
</ol>
<p>解释：<br>
对于第一点 同名不同参 同作用域为重载 不同作用域为隐藏<br>
对于第二点 同名同参 是虚函数 则覆盖 不是虚函数则隐藏</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602133459.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">上</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived *pd = <span class="keyword">new</span> Derived;</span><br><span class="line">pd—&gt;f(<span class="number">10</span>);—_<span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; Base::f(x); &#125; / 调用传递</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>void Foo(int x = 0, int y = 0); / 正确 默 认值 出现在 函数 的 声明 中<br>
如 果 函 有 多 个 参数 参 数 只 能 从 后 向 前 依次 默认</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602134849.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602135659.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602135956.png" alt=""></p>
<p>C++ 标准 规定 当 为 一 类 型 重 “<ins>”/“–” 的 前 置 本 时 不需要 参数<br>
当 为 一 个 类 型 重 “</ins>”/“–” 的 后 置 本 时 ， 需 要 一 int 类 型 的 参数 作为标志 〈 即 哑 元 非 具名 参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Integer(<span class="keyword">long</span> data) : m_data(data)&#123; &#125;</span><br><span class="line">Integer&amp; <span class="keyword">operator</span>++() &#123; /W 前 置 版 : 返回 引用</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; “Integer::<span class="keyword">operator</span>++() called!” &lt;&lt; <span class="built_in">end</span>];</span><br><span class="line">m_datat++ ;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="comment">// 后 置 版 : 返回 对 象 的</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">"Integer::operator++(int) called!"</span> &lt;&lt; <span class="built_in">end</span>];</span><br><span class="line">Integer temp = *<span class="keyword">this</span> ;</span><br><span class="line">m_data++ ; <span class="comment">// BR: ++(*this) ;</span></span><br><span class="line"><span class="keyword">return</span> temp; / 返回 <span class="keyword">this</span> 对 象 的 旧 值</span><br><span class="line">&#125;</span><br><span class="line">/ 其 他 成 员</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">long</span> m_data; / 对 <span class="keyword">long</span> 的 封装</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Integer x = <span class="number">1</span>; <span class="comment">// call Integer(long)</span></span><br><span class="line">+<span class="number">4</span>x ; <span class="comment">// call operator++Q)</span></span><br><span class="line">xtt+ <span class="number">3</span> <span class="comment">// call operator++(int)</span></span><br><span class="line">&#125;</span><br><span class="line">输出 结果 :</span><br><span class="line">Integer::<span class="keyword">operator</span>++() called!</span><br><span class="line">Integer::operatort++(<span class="keyword">int</span>) called!</span><br></pre></td></tr></table></figure>
<h3 id="内联"><a class="header-anchor" href="#内联">¶</a>内联</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(intx, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(intx, <span class="keyword">int</span> y)</span> <span class="comment">// inline 与 函数 定义 体 放 在 一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义 在类 声明 之 中 的 员 函 数 将 自动地 成 内 联 函数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; ... &#125; / 自动 地 成 内 联 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换函数"><a class="header-anchor" href="#类型转换函数">¶</a>类型转换函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyString(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">char</span> c =</span><br><span class="line">fhe.</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *m_data;</span><br><span class="line">Point pl = <span class="number">10.5</span>;</span><br><span class="line">pi = <span class="number">20.5</span>;</span><br><span class="line">\<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString strName = <span class="number">20</span>;</span><br><span class="line">strName = <span class="number">40</span>; / 莫名 其妙 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(MyString str)</span></span>;</span><br><span class="line">f(<span class="number">100</span>);</span><br><span class="line">如果 当 前程序 中 没有 其 他 重 载 恕 函数， 编译 器 就 将 它暗 中 转换 :</span><br><span class="line">f(MyString(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p>当你的类定义中出现类似的情况时，可以在构造函数前面添加关键字 explicit<br>
将其 声明 为 显 式 的 意 为要 求 用 户 必须 显 式 地 调用 该 构造 函数 来 初始 对 象<br>
以 明确 表明 他 的 意图</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602141650.png" alt=""></p>
<ol>
<li>
<p><code>static_cast&lt;desttype&gt;(src_obj)</code>， 作 用 相当 于 C 风格 的强制 转换 ,<br>
但 是 在 多 重继承 的情况 ， 它 会 正确 地 调整 指针 的 值<br>
而 C 风格 的强制 转换 则 不 会调整<br>
它 可 以 遍历继承 树 来 确定 src_obj 与 dest_type 的 关系 ,<br>
但 是 只 在 编译 时进行 〈 此 所 谓 静 )，<br>
如 果使 用 它 来 downcast 操作 ， 则 会 存在 隐患 。</p>
</li>
<li>
<p><code>const_cast&lt;dest_type&gt;(src_obj)</code>， 用 于去除 一 个对 象 const/volatile 属性</p>
</li>
<li>
<p><code>reinterpret_cast&lt;desttype&gt;(src_obj)</code>, 我 们 可 以借助 它 把 一 个 整数 转换 成 一地 址 或 者 在任何 两 种 类 型 的 指针 之闻 转 。 使 用 该 运算 符 的 结果 很 危险 ，请你 要 轻易使</p>
</li>
<li>
<p><code>dynamic_cast&lt;dest_type&gt;(src_obj)</code>， 在 运行 时 台历 继承 〈 类 层次 结构 ) 来确定 src_obj 与 desttype 的 关系</p>
</li>
</ol>
<p>在 C++ 程序 中 尽量 不 要 再 使 C 风格 的 类 型 转换<br>
除 非 源 对 和 目标 类型 都 <strong>基本 类 型</strong> 的对 象 指针 ， 否 则 很 不 安全 。<br>
C++ 的 类 型 转换 运算 符在 需要 的 时 候 会 进行<strong>指针 调整</strong> 因 此 结果 比较 安全 。</p>
<h3 id="const成员函数"><a class="header-anchor" href="#const成员函数">¶</a>const成员函数</h3>
<p>任何 不 会修改 数据 员 的 员 函 数 都应 该 声明 为 const 类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const A AB</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_num;</span><br><span class="line"><span class="keyword">int</span> m_data[ <span class="number">100</span>&#125;;</span><br><span class="line">I</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Stack::GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">t</span></span><br><span class="line">++m_num; / 编译 错误 企 图修改 数据 成 m_num</span><br><span class="line">Pop(); / 编译 错误 企 图 调用非 <span class="keyword">const</span> 成 员 函</span><br><span class="line"><span class="keyword">return</span> m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Static KA BRA RANA const 的 这 是 因为 static 成 员 函 数 只 是 全 局 函 数 的 一 个 形式 上 的 封装 而 全 局 函数 不 存在 const 一 ; 何况 static 成 员 函数 不 能 访问 类 的 非 静态 成 (没有 this 指针 )， 修 改 非 静态 数据 员 又 从 何说 起 ?</p>
<h2 id="10-C-异常处理-和-RTTI"><a class="header-anchor" href="#10-C-异常处理-和-RTTI">¶</a>10. C++异常处理 和 RTTI</h2>
<p>何 一 种 类 型 可 以 当做 异常 类 型 因 此 任何 个 对 象 可 以 当做异常 对 ，<br>
包括 基本 数据 类 型 的 变量 常量、 任何 类 型 的 指针 、 引 用 、 结 构 等 甚 至 空 结构类 的 对象<br>
这 是 因为 异常 仅仅通过 类 型 而不是 通过 值 来 匹配 的 否 则 就 又 退回 到<br>
了 传统 的 错误 处 理 技术 上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> x = <span class="number">100</span>, y = <span class="number">20.5</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">20</span>] = &#123; <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Devide(x, y) &lt;&lt; <span class="built_in">endl</span>; / 可 能 抛 出 异常 DevidedByZero</span><br><span class="line"><span class="keyword">if</span>(index &gt;= <span class="number">20</span>) <span class="keyword">throw</span> OverFlow(); <span class="number">1</span>) iE EGLF <span class="number">4</span> Bil <span class="keyword">try</span> RA</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>) <span class="keyword">throw</span> UnderFlow(); / 抛 出 点 位 于 当前 <span class="keyword">try</span> 块 内</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> DevidedByZero&amp; ex) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; ex.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> OverFlow&amp;) &#123; / 省 略 参数 名 称</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"Overflow occurred!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> UnderFlow&amp;) &#123;</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"Underflow occurred!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123; / 捕获 他所 有 可 能 的 异常</span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unexpected exception occurred!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 于 异常 处理 机 制 采用 类 型 匹配 而 不 是 值 判 断 因 此 catch 块 参数<br>
可 以 没有 参数 名 称 只 需要 参数 类 型 除 非 确实 要 使 用 那个 异常 对</p>
<p>虽然 异常 对 象 上 去 局 部 对 象 但 是 并 非 创建 在 函数 堆栈 上 ，<br>
而 是创建 在 专用 的 <strong>异常 堆栈</strong> 上 ， 因 此 它 才 可 以 跨接 多 个 函数 而 传递 上 层 ，<br>
否则 在 堆栈 清 退 的 过 程 中 就 会 销毁 .<br>
<strong>不 要</strong> 企图 把 <strong>局 部 对 象 地 址</strong> 作为异常 对 象 <strong>抛 出</strong><br>
因 为 局 部 对 象 会 蜡 常 出 后 函数 堆栈 清 退 的 过 程 中销毁</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602161511.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Devide</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> <span class="title">throw</span><span class="params">(DevidedByZero)</span></span>;  <span class="comment">// 只 可 能 出 一种 异常</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *)</span> <span class="title">throw</span><span class="params">(T1, T2,T3)</span></span>; <span class="comment">// 可 能 抛 3 种 异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// (3) 不抛出任何异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">k</span><span class="params">()</span></span>;  <span class="comment">// 可 能 出 任何 异常 也 可能 不 出 任何异常</span></span><br></pre></td></tr></table></figure>
<p>所 有从try 到 throw 语句 之间 构造 起 来 的 局 部对 象 的析 构 函数将被 自动 调用<br>
(以 与构造相 反 的 顺序 )， 然 后 清 退 堆栈 (就像 函 数 正 退出 那样 )。</p>
<p>如 果 一 个 函数 在 运行 时 抛 了 异常<br>
于 是 异常 处 理 机制 调用 局 部 对 象 析构 函数 〈 清退 扒 )，<br>
而如 果 此 时 某 一 析 构 函 数 恰 也 要 抛 出一 个 异常 那 这个 异常 由 谁 处 理 ?<br>
没有 办 法 异 常 处 理 机 制 只 好 调用;terminate0。</p>
<p>如 果 你 真 的 不 得 不 从 析 构 函数 内 抛 出 异常 的 话 你应 该<br>
首先 检查一 下 看 当前 是 有 一 个 未 捕获 的 异常 要 被 处 理 如 果 没有 ，<br>
说 明 该 析 构 函数 的用 并 非 由 一 外 部 异常 引起 而 是 正常 的 销毁<br>
于是 你 可 以 出 一 个 异常 上 层:程序 来 捕获</p>
<p>一 些 编译 器可 以 设 异 常 处 理 支持 开关 ， 当 关闭 异常 理 支持 后 附加 的 数据 结构 查 找表 、 额 外 的 代码 都 不 生成</p>
<p>要 合理 安排 异常 处 理 的 层次 : 一 要 把 派生 类 的 异常 .<br>
获 放 在 基 类 异常 捕获 的 前 面 否 则派生 类 异常 匹配 永远 也 不 会执行到</p>
<p>如 果实 在 无 法判断 到 底 有什么 异常 抛 出 那 就 使 “一 打 尽”的 策<br>
略 了 : catch(void*) 和 catch(…)。 但 要 记 住 catch(void*) 和 catch(…)<br>
必须 放 在 异常 组 合 的 最 后 面 并 且 cateh(void*) 放 在 catch(…) 的 前</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230602165212.png" alt=""></p>
<p>为 了 支持 dynamic_cast&lt;&gt; 运 算 符 ，RTTI 机 制 必须 维 护 一 棵 继承 ，<br>
即 base class table 模型 ( 或 类 似 的 索引 表格 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeviceControllor::ControlThem</span><span class="params">(HomeElectricDevice&amp; device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Command cmd = GetCommand();</span><br><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> OPEN:</span><br><span class="line"><span class="keyword">case</span> PLAY VCD:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Television tv = <span class="keyword">dynamic_cast</span>&lt;Television &amp;&gt;(device);</span><br><span class="line">tv.PlayVCDQ; <span class="comment">// PRCERESE ADEE Television WRAEAIE BCH!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="built_in">std</span>::bad_cast&amp;) &#123;</span><br><span class="line">MsgBox(<span class="string">"This device cannot play VCD!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="11-16章-内存管理"><a class="header-anchor" href="#11-16章-内存管理">¶</a>11. 16章 内存管理</h2>
<p>野 指 针<br>
free 完 delete完 置NULL</p>
<p>对 于 内 部 数据 类 (如 ADT/UDT) 的 对 象 而 言 光 用 mallocO/free0 无 法 满足 动态 对 象 的 要 求<br>
对象 在 创建 的 同时 要 <strong>自动 调用 构造 函数</strong> 对象在 销毁 的 时 候要 <strong>自动 调用 析 构 函数</strong><br>
由 mallocO/free0 是 库 函 数而 不 是 运算 符 不 在 编译 器 控制 权限<br>
不 能 把调用 构造函数 和 析 构 函数 的任务强加 给 它们 。<br>
因 此 C++ 语言 需要 一能 完成 动态 内 存 分 和 初始 化 工作 的运算 new,<br>
以 及一 个 能 够 完成清 理与 释放 内存工作 的运算符 delete。</p>
<p>plain new、nothrow new 及 placement new.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 的 使 用 方 法 见 示 例 <span class="number">16</span><span class="number">-10</span>。</span><br><span class="line"><span class="comment">// plain new 定义</span></span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">std</span>::<span class="keyword">size_t</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc);</span><br><span class="line">| <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Char * <span class="title">GetMemory</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>)</span></span></span><br><span class="line">《</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">size</span>];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">char</span> *p = GetMemory(<span class="number">1000000</span>); / 可 能 抛 出 <span class="built_in">std</span>::bad_alloc 异 常</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc&amp; ex) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// nothrow new 定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">unsigned</span> <span class="keyword">char</span>[length];</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"allocate failed!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Hf...</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>placement new 不 用 担心 内 存 分配 失败 因 为 它 根本 就 不 会 分配 内 存<br>
它所 做 的 唯一 一件 事情 就 是 调用 对 象 的 构造 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include &lt;<span class="keyword">new</span>&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">char</span>[<span class="number">4</span>]; <span class="comment">// nothrow new</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"allocate failed!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">仁 …</span><br><span class="line"><span class="keyword">long</span> *q = <span class="keyword">new</span>(p) <span class="keyword">long</span>(<span class="number">1000</span>); <span class="comment">// placement new</span></span><br><span class="line">Ie.</span><br><span class="line"><span class="keyword">delete</span> [ip; / 释放 内 存</span><br></pre></td></tr></table></figure>
<p>Placementnew 的 主 要 用 途 就 是 : 反 复 使 用 一 块 较 大 的 动 态 分 配 成 功 的 内 存 来 构 造 不 同 类 型 的 对 象 或 者 它 们 的 数 组 。 比 如 , 可 以 先 申 请 一 个 尸 够 大 的 字 符 数 组 , 然 后 当 需 要 时 在 它 上 面 构 造 不 同 类 型 对 象 或 其 数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> “ 使 用 placement <span class="keyword">new</span> 构 造 起 来 的 对 象 或 其 数 组 , 要 显 式 地 调 用 它 们 的 析 构 函 数 来 销 毁 ( 析 构 函 数 并 不 释 放 对 象 的 内 存 , 千 万 不 要 使 用 <span class="keyword">delete</span>。 这 是 因 为 ,placement <span class="keyword">new</span> 构 造 起 来 的 对 象 或 其 数 组 的 大 小 并 不 一 定 等 于 原 来 分 配 的 内 存 大 小 , 因 此 使 用 <span class="keyword">delete</span> 会 造 成 内 存 泄 漪 , 或 者 在 之 后 释 放 内 存 时 出 现 运 行 时 错 误 。 见 示 例 <span class="number">16</span><span class="number">-14</span> ( 假 设 ADT 表 示 任 意 复 合 数 据 类 # ).</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-14</span></span><br><span class="line">#include &lt;<span class="keyword">new</span>&gt;</span><br><span class="line">#include &lt;iostrem&gt;</span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>)</span><br><span class="line">《</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>:</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">new</span>(nothrow) <span class="keyword">char</span>[<span class="keyword">sizeof</span>(ADT) + <span class="number">2</span>]:; / nothrow <span class="keyword">new</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"allocate failed!"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ADT *q = <span class="keyword">new</span>(p) ADT; <span class="comment">// placement new: 不 必 担 心 失 败</span></span><br><span class="line">历 .</span><br><span class="line"><span class="comment">// deleteq; / 错 误 ! 不 能 在 此 处 调 用 deleteq;</span></span><br><span class="line">q-&gt;ADT::-ADTO; / 显 示 调 用 析 构 函 数</span><br><span class="line"><span class="keyword">delete</span> []p; / 再 释 放 内 存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="12-用对象模拟指针"><a class="header-anchor" href="#12-用对象模拟指针">¶</a>12. 用对象模拟指针</h2>
<p>些 软 件 库 使 用 这 种 技 术 来 封 装 指 针 , 基 本 上 分 为 如 下 几 种 情 况 。</p>
<ol>
<li>采 用 拷 贝 方 式 。 这 样 的 指 针 对 象 既 负 责 创 建 数 据 对 象 , 又 负 责 删 除 数 据 对<br>
象 ,STL 容 器 对 象 采 用 的 就 是 这 种 方 式 。显 然 , 采 用 这 种 方 式 的 指 针 对 象<br>
责任 最 清 晰 。</li>
<li>采 用 完 全 接 管 方 式 , 指 针 对 象 不 负 责 创 建 数 据 对 象 , 但是负责删除数据对<br>
象 , 即 不 仅 接 管 了 源 指 针 指 向 的 对 象 , 而 且 接 管 了 它 的 所 有 权 。auto ptr&lt;&gt;<br>
类 就 是 采 用 这 种 方 式 实 现 的 。</li>
<li>采 用 接 管 方 式 , 是 既 不 负 责 创 建 数 据 对 象 也 不 负 责 删 除 数 据 对 象 , 这 就 是<br>
我 们 的 模 拟 指 针 。STL 中 的 迭 代 器 (iterator》 采 用 的 就 是 这 种 方 式 , 它们 在<br>
行 为 上 与 底 层 的 指 针 变 量 没 有 什 么 太 大 区 别 , 只 是 在 使 用 方 式 上 统 一 了 起<br>
来 。</li>
<li>完 全 接 管 方 式 和 深 拷 贝 方 式 结 合 。 一 般 情 况 是 : 拷 贝 构 造 和 拷 贝 赋 值 采 用<br>
深拷 贝 方 式 , 而 指 针 构 造 和 指 针 赋 值 采 用 接 管 方 式 。 这 种 方 式 最 容 易 产 生<br>
运 行 时 内 存 访 问 冲 突 和 内 存 泄 漏 问 题 , 因 此 建 议 不 要 使 用 。</li>
</ol>
<h3 id="泛型指针auto-ptr"><a class="header-anchor" href="#泛型指针auto-ptr">¶</a>泛型指针auto_ptr</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span> 【</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">autp_ptr</span><span class="params">(T *p = <span class="number">0</span>)</span> : <span class="title">m_ptr</span><span class="params">(p)</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">auto_ptr</span>(<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;T&gt;&amp; copy) : m_ptr(copy.<span class="built_in">release</span>())&#123;&#125;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;T&gt;&amp; assign) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;assign) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">m_ptr = assign.<span class="built_in">release</span>(); H 释 放 并 移 交 拥 有 权</span><br><span class="line">多</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">hs</span><br><span class="line">~<span class="built_in">auto_ptr</span>()&#123; <span class="keyword">delete</span> m_ptr; &#125; / 负 责 释 放 存 储</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()&#123; <span class="keyword">return</span>.*m_p; &#125; / 重 载 “*<span class="number">2</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()&#123; <span class="keyword">return</span> m_p; &#125; / 重 载 “-&gt;“</span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">T *temp = m_ptr;</span><br><span class="line">(<span class="keyword">const_cast</span>&lt;<span class="built_in">auto_ptr</span>&lt;T&gt; *&gt;(<span class="keyword">this</span>))-&gt;m_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">工 * m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使 用 auto_ptr&lt;&gt; 这 样 的 灵 巧 指 针 有 一 个 好 处 : 当 函 数 即 将 退 出 或 有 异 常 抛 出 的 时 候 ,<br>
不 再 需 要 我 们 显 式 地 用 delete 来 删 除 每 一 个 动 态 创 建 起 来 的 对 象</p>
<h3 id="带引用技术的智能指针"><a class="header-anchor" href="#带引用技术的智能指针">¶</a>带引用技术的智能指针</h3>
<p>带 有 引 用 计 数 功 能 的 智 能 指 针 兼 有, 智 通 指 针 共 享 实 值 对 象 和 auto ptr 自 动 释 放 实 值 对 象 的 双 重 功 能</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603113212.png" alt=""></p>
<p>“auto_ptr不 满 足 STL 标 准 容 器 对 元 素 的 最 基 本 要 求<br>
,auto ptr 对 象 和 它 的 拷 贝 不 会 共 享 实 值 | 对 象 , 任 何 两 个 auto_ptr 也 不 应 该 共 享 同 一 个 实 值 对 象 。 这 就 是 说 ,auto ptr 对 象 和 | 它 的 拷 贝 并 不 相 同 。 然 而 根 据 STL 容 器 “ 值 “ 语 义 的 要 求 , 可 拷 贝 构 造 意 味 着 一 个 || 对 象 必 须 和 它 的 拷 贝 相 同 ( 标 准 中 的 正 式 定 义 比 这 稍 复 杂 一 些 。 同 样 , 可 赋 值 意 味 耒萱把 个 对 象 赋 值 给 另 一 个 同 类 型 对 象 将 产 生 两 个 相 同 的 对 象 。 显 然 ,auto ptr 不 能 LK 要 求 , 它 与 上 面 的 结 论 矛 盾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">16</span><span class="number">-23</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt; <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; la; / <span class="built_in">auto_ptr</span> 列 表</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">la.push_back(p1); <span class="comment">// compiling-error!</span></span><br><span class="line">la.push_back(p2); <span class="comment">// compiling-error!</span></span><br><span class="line">la.push_back(p3); <span class="comment">// compiling-error!</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; sa; / <span class="built_in">auto_ptr</span> RA: 假 设 为 <span class="keyword">auto</span> ptr 定 义 了 <span class="keyword">operator</span>&lt;</span><br><span class="line">sa.insert(p1); <span class="comment">// compiling-error!</span></span><br><span class="line">sa.insert(p2); <span class="comment">// compiling-error!</span></span><br><span class="line">sa.insert(p3); <span class="comment">// compiling-error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">list</span>&lt;T&gt;::push_back(<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">T *p = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(T)); / 分 配 内 存空 间</span><br><span class="line"><span class="keyword">new</span> (p) T(x); <span class="comment">// placement new, 调 用 T 的 copy constructor</span></span><br><span class="line">------ / 将 p 交 给 容 器 管 理 , 调 整 容 器 大 小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; IntPtrVector;</span><br><span class="line">IntPtrVector va;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">4</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">va.push_back(p1);</span><br><span class="line">va.push_back(p2);</span><br><span class="line">va.push_back(p3);</span><br><span class="line">va.push_back(p4);</span><br><span class="line">va.push_back(p5);</span><br><span class="line"><span class="number">1</span> ( 注意 : 以 下 操 作 并 非 放 在 一 起 进 行 , 仅 是 示 范 )</span><br><span class="line">IntPtrVector vb = va; va 丧 失 对 所 有 实 值 对 象 的 拥 有 权 ,</span><br><span class="line">/ 元 素 成 为 <span class="literal">NULL</span> 指 针</span><br><span class="line">vb.resize(<span class="number">10</span>); / 新 增 的 元 素 都 为 <span class="literal">NULL</span>指 针</span><br><span class="line"><span class="built_in">std</span>::sort(vb.<span class="built_in">begin</span>(),</span><br><span class="line">vb.end0);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">t</span><br><span class="line">=</span><br><span class="line">vb.front();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">改</span><br><span class="line">变</span><br><span class="line">了</span><br><span class="line">容</span><br><span class="line">器</span><br><span class="line">元</span><br><span class="line">素</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; r = vb[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; la;</span><br><span class="line"><span class="built_in">std</span>::copy(vb.<span class="built_in">begin</span>(), vb.<span class="built_in">end</span>(), <span class="built_in">std</span>::back_inserter(la));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>Scott Meyers 在 《Effective STL) Item 8 中 详 细 地 分 析 了 对 auto ptr 容 器 进 行 排 序<br>
| 时 可 能 会 导 致 的 问 题 。 但 是 在 MS VC++ 环 境 下 经 测 试 , 并 没 有 出 现 书 中 所 描 述 的 悲<br>
| 惨 结 局 , 而 是 结 果 正 确 。 主 要 原 因 在 于 C++ 标 准 并 没 有 要 求 std::sort等 泛 型 算 法 的 实<br>
现 必 须 采 用 某 一 种 方 法 , 而 是 只 规 定 了 它 们 的 接 口 、 功 能 和 应 该 达 到 的 性 能 要 求 ( 容<br>
器也 是 如 此 )。 因 此 , 不 同 的 STL 实 现 可 能 采 取 不 同 的 方 法 , 比 如 有 的 sort 实 现 采 用<br>
快速 排 序 法 , 而 有 的 采 用 插 入 式 排 序 法 等 。 不 同 的 排 序 方 法 在 遮遇 auto_ptr这 样 的 容<br>
| 器 时 可 能 就 会 产 生 不 同 的 结 果</p>
<p>可 见 , 督 能 指 针 “ 可 以 “ 还 是 “ 不 可 以 “ 作 为 容 器 的 元 素 并 非 绝 对 的 , 不 仅 与 ,STL 的 实 现 有 关 , 而 且 与 STL 宪 器 的 需 求 和 安 全 性 及 容 器 的 语 义 有 关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">由于 <span class="built_in">auto_ptr</span> 是 对 象 化 的 智 能 指 针 , 具 有 自 动 释 放 资 源 的 能 力 , 因 此 它 真 正 有 价</span><br><span class="line">, 值 的 用 途 是 在 发 生 异 常 时 避 免 资 源 泄 濡 。 比 如 , 如 果 不 使 用 <span class="keyword">auto</span> ptr, 则 下 列 代 码 在</span><br><span class="line">发 生 异 常 的 情 况 下 不 得 不 多 次 手 工 释 放 资 源 ( 见 示 例 <span class="number">16</span><span class="number">-28</span>)。</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-28</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> ... &#125;<span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line">《</span><br><span class="line">A *pA= 一 <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wee <span class="comment">// using *pA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(...) &#123;</span><br><span class="line"><span class="keyword">delete</span> pA; MBERTAIN BE LAE IK</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> pA; / 函 数 退 出 时 还 要 显 式 释 放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现 在 有 了 <span class="keyword">auto</span> ptr, 我 们 就 可 以 这 么 做 ( 见 示 例 <span class="number">16</span><span class="number">-29</span>).</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-29</span> |</span><br><span class="line">classA&#123; ... &#125;<span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="comment">// using *pA</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果 想 防 止 无 意 中 修 改 <span class="keyword">auto</span> ptr 对 实 值 对 象 的 拥 有 权 , 可以 使 用 <span class="keyword">const</span> <span class="built_in">auto_ptr</span>,</span><br><span class="line">! 这 样 的 <span class="built_in">auto_ptr</span> 只 能 使 用 引 用 或 指 针 传 递 , 不 能 使 用 值 传 递 , 也 不 能 赋 值 和 拷 贝 构 造 </span><br><span class="line"></span><br><span class="line">classA&#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">auto_ptr</span>&lt;A&gt; <span class="title">pl</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">we <span class="comment">// using *pA</span></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;A&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// error!</span></span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;A&gt; p3;</span><br><span class="line">p3=pl; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// smart pointer stl</span></span><br><span class="line"></span><br><span class="line">示 例 <span class="number">16</span><span class="number">-31</span></span><br><span class="line">) <span class="keyword">typedef</span> SmartPtr&lt;Shape&gt; ShapeSmartPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;ShapeSmartPt&gt; ShapeList;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point&amp; left, <span class="keyword">const</span> Point&amp; right)</span><br><span class="line">&#123; <span class="keyword">return</span> ((left.m_x &lt; right.m_x) &amp;&amp; (left.m_y &lt;right.m_y); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>—=(<span class="keyword">const</span> Point&amp; left, <span class="keyword">const</span> Point&amp; right)</span><br><span class="line">&#123; <span class="keyword">return</span> ((left.m_x == right.m_x) &amp;&amp; (left.m_y == right.m_y); )</span><br><span class="line">| <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ShapeSmartPtr left, <span class="keyword">const</span> ShapeSmartPtr right)</span><br><span class="line">&#123; <span class="keyword">return</span> (left-&gt;GetOriginQ &lt; right-&gt;GetOrigin()); 》</span><br><span class="line"><span class="number">1</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ShapeSmartPtr left, <span class="keyword">const</span> ShapeSmartPtr right)</span><br><span class="line">&#123; <span class="keyword">return</span> (left-&gt;GetOriginQ == right-&gt;GetOrigin()); &#125;</span><br><span class="line">ShapeList shapes;</span><br><span class="line">ShapeSmartPtr p(<span class="keyword">new</span> Shape(Point(<span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">ShapeSmartPtr q(<span class="keyword">new</span> Circle(Point(<span class="number">2</span>, <span class="number">2</span>), <span class="number">5</span>));</span><br><span class="line">ShapeSmartPtr r(<span class="keyword">new</span> Rectangle(Point(<span class="number">3</span>, <span class="number">3</span>), Point(<span class="number">4</span>, <span class="number">4</span>)));</span><br><span class="line">shapes.push_back(p);</span><br><span class="line">shapes.push_back(q);</span><br><span class="line">shapes.push_back(r);</span><br><span class="line">|</span><br><span class="line"><span class="built_in">std</span>::sort(shapes.<span class="built_in">begin</span>(), shapes.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ShapeList::const_iterator first=shapes.<span class="built_in">begin</span>();first !=shapes.<span class="built_in">end</span>();++first)</span><br><span class="line">(*first)-&gt;DrawQ);</span><br></pre></td></tr></table></figure>
<h2 id="13-17章-STL"><a class="header-anchor" href="#13-17章-STL">¶</a>13. 17章 STL</h2>
<p>STL 主 要 包 括 下 面 这 些 组 件<br>
IO流、 string 类 、 容 器 类(Container)、 迭 代 器 熹 (Iterator)、 存 储 分 配 器 (Allocator)、<br>
适 配 器 (Adapter)、 函 数 对 象 (Functor)、 泛 | 型 算 法 (Algorithm)、<br>
数 值 运 算 、 国 际 化 和 本 地 化 支 持 , 以 及 标 准 异 常 类 等 。</p>
<p>C<ins>标 准 规 定 , STL 的 头 文 件 都 不 使 用 扩 展名<br>
过 去 的 C 程 序 库 头 文 件 在, 并 入 C</ins> 标 准 库 时 也 都 去 掉 了 .h 扩 展 名 , 同 时 增 加 了 前 缀 “c“。<br>
STL 组 件 都 被 纳 入 了 名 字 空 间 std::, 所 以 在 使 用 其 中 的 组 件 之 前 需 使 用 using 声 明 或 using 指 令 ,<br>
或 者 也 可 以 在 每 一 处 都 直 接 使 用 完 全 限 定 名 std::。</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603051215.png" alt=""></p>
<h3 id="STL头文件分布"><a class="header-anchor" href="#STL头文件分布">¶</a>STL头文件分布</h3>
<h3 id="容器类"><a class="header-anchor" href="#容器类">¶</a>容器类</h3>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603050007.png" alt=""></p>
<pre><code>关 联 式 容 器 multimap 和 multiset 也 都 分 别 定 义 在 &lt;map&gt; 和 &lt;set&gt; 中 ,
hash_multimap 和 hash_multiset 定 义 在 &lt;hash_map&gt;和&lt;hash_set&gt;中
</code></pre>
<h3 id="泛型算法"><a class="header-anchor" href="#泛型算法">¶</a>泛型算法</h3>
<pre><code>像 C++VC 数 组 、 字 符 留 、UO 流 等 特 殊 的 容 器 也 可 以 使 用 标 些 泛 型 算 法 一 一
它 们 定 义 在 头 文 件 &lt;algorithm&gt;和 &lt;utility&gt; 中 
</code></pre>
<h3 id="迭代器"><a class="header-anchor" href="#迭代器">¶</a>迭代器</h3>
<pre><code>如 输 入 / 输 出 迭 代 器 、 插 入 迭 代 器 、 反 向 迭 代 器 等 都 是 迢 代 器 适 配 器 , 
定 义 在 头 文 件 &lt;iterator&gt;中 
</code></pre>
<h3 id="数学运算库"><a class="header-anchor" href="#数学运算库">¶</a>数学运算库</h3>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603050515.png" alt=""></p>
<h3 id="通用工具"><a class="header-anchor" href="#通用工具">¶</a>通用工具</h3>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603050604.png" alt=""></p>
<h3 id="其他头文件"><a class="header-anchor" href="#其他头文件">¶</a>其他头文件</h3>
<pre><code>&lt;typeinfo&gt; 、&lt;stdexcept&gt;、&lt;strsteam&gt;、&lt;string&gt;、&lt;istream&gt;、
&lt;ostream&gt;、&lt;iostream&gt;、&lt;new&gt;、&lt;iomanip&gt;、&lt;fstream&gt; 
</code></pre>
<h3 id="容器设计原理"><a class="header-anchor" href="#容器设计原理">¶</a>容器设计原理</h3>
<p>容 器 在 概 念 上 是 一 种 可 以 动 态 增 大 和 减 小 的 模 型<br>
其<strong>元 素 对 象</strong> 在 实 现 上 不 可 能 直 接 保 存 在 容 器 对 象 里 面<br>
应 该 保 存 在 自 由 内 存 (Free Memory) 或 堆 , CHeap)》 上</p>
<h3 id="内存映像"><a class="header-anchor" href="#内存映像">¶</a>内存映像</h3>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603051108.png" alt=""></p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603052000.png" alt=""></p>
<h3 id="存储方式-访问方式"><a class="header-anchor" href="#存储方式-访问方式">¶</a>存储方式 访问方式</h3>
<p>向 量 Cvector) 和 链 表 (linked list) 是 两 种 最 基 本 的 动 态 结 构 ,<br>
也是 STL 中 两 种 最 基 本 的 容 器 ,<br>
分 别 对 应 动 态 数 组 和 链 接 表 结 构<br>
同 时 它 们 分 别 代 表 了 内 存 中 同 类型 批 量 数 据 存 放 的 两 种 基 本 方 式 , 连 续 存 储 和 随 机 存 储 ( 不 连 续 存 储 )。</p>
<p>随 机 访 问 就 是 指 可 以 直 接 通 过 开 销 恒 定 的 算 术 运 算 来 得 到 任 一 元 素 的 内 存 地 址 的 访 问 方 法</p>
<p>顺 序 访 问 则 是 指 必 须 从 第 一 个 元 素 开 始 遍 历 , 直 到 找 到 所 需 的 元 素 对 象 为止 ,<br>
而 无 法 直 接 得 到 任 一 中 间 元 素 对 象 的 地址</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603052600.png" alt=""></p>
<p>stack、queue 及 priorityqueue 在 概 念 和 接 口 上 都 不 支 持 随 机 访 问和 遍历 ,<br>
这 是 由 它 们 的 语 义 决 定 的 , 而 不 是 由 底 层 存 储 方 式 决 定 的 , 因此 没 有 选 代 器<br>
( 所 以 它 们 才 被 叫 做 容 器 近 配 器 而 不 是 归 为 容 器 类 ),</p>
<p>这 两 种 基 本 的 存 储 方 式 可 以 演 变 出 各 种 不 同 的 存 储 方 式 ,<br>
比 如 分 层 连 续 存 储 、 树 (Tree)、 邻 接 表 、 图 等 , 甚 至 可 以 把 二 者 组 合 起 来</p>
<p>就 拿 “ 树 “ 来 说 , 它 在 本 质 上 就 是 一 种 特 殊 的 链 表 结 构 , 因 此 只 能 顺 序 访 问 ,<br>
即 从 某 个 节 点 开 始 搜 索 直 至 到 达 所 要 访 问 的 元 素 对 象 ,<br>
或 者 采 用 深 度 优 先 、 广 度 优 先 或 者 前 序 、 中 序 、 后 序 等 方 法 遍 历 整 棵 树 ,<br>
但 是 不 可 能 直 接 定 位 到 树 上 的 任 一 个 结 点 对 象 。</p>
<p>主 要 有 一 叉 搜 索 树 (binary-search)、 平 衡 二 叉 树 (balanced binary search). 红 黑 树 (red-black) 等</p>
<p>由于 红 黑 树 ( 平 衡 二 又 搜 索 树 的 一 种 ) 在 元素 定 位 上 的 优 异 性 能 (CO(logyW),STL 通 常 使 用 它 来 实 现 关 联 式 容 器</p>
<p>顺序 容 器 主 要 采 用 向 量 和 链 表 及 其 组 合 作 为 基 本 存 储 结 构 , 如 堆 栈 和 各 种 队 列<br>
而 关 联 式 容 器 采 用 平 衡 二 叉 搜 索 树 作 为 底 层 存 储 绪 构</p>
<p>由 于 顺 序 容 器 本 来 就 有 “ 序 “, 所 以 它 是 通 过 元 素 对 象 在 容 噬 中 的位 置 来标 识 一 个 元 素 的 ,<br>
而 不 是 通 过 元 素 的 值 ( 因 为 它 可 以 存 储 值 相 等 的 多 元 素 对 象 , 而 且 它 们 的 位 置 不 一 定 相 邻 ),<br>
这 也 就 是 调 用 顺 序 容 器 的 insert0 函 数 和 erase0 函 数 时 必 须 指 定 插 入 位 置 和 删 除 位 置<br>
而 不 能 仅 指 定 元 素 值 的 原 因 .<br>
当 然 , 关 联 式 容 噩 也 能 存 储 值 相 等 的 元 素 , 比 如 multimap 和 multiset 等 ,<br>
但 是 它 们 在 容 器 中 的 位 置 肯 定 是 相 邻 的</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603055357.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Container:iiterator first = theContainerObj.<span class="built_in">begin</span>(),</span><br><span class="line">fast = theContainerObj.<span class="built_in">end</span>(Q);</span><br><span class="line">first != last;</span><br><span class="line">++first) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; first-&gt;.,. &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*first)... &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">/</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Inputlterator <span class="title">find</span><span class="params">(Inputlterator first, Inputfterator last, <span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(first != last &amp;&amp; *first != value) ++first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hash table 及 由 它 演 化 出 来 的 hash_set/ hash_map/hash_ multiset/hash_multimap<br>
作 为 关 联 式 容 磐 加 进来</p>
<p>STL 容 器 采 用 拷 贝 方 式 来 接 收 待 插 入 的 元 素 对 象 一 一 在 插入 的 时 候 容 器<br>
自 动 新 建 等 量 的 元 素 对 象 , 并 用 待 插 入 对 象 依 次 初 始 化 它 们 ( 调 用 拷 贝 构 造 函 数</p>
<p>在 删 除 元 素 时 , 容 器 负 责 释 放 其 内 存 资 源 ( 对 札 用 随 机 存 储 策 略 的 容 器 )<br>
或者 仅 仅调 用 元 素 的 析 构 函 数 ( 对 采 用 连 续 存 储 策 略 的 容 器</p>
<p>对 象 类 型 一 般 需 要 符 合 下 述 要 求 , 才 能 够 作 为 STL 容 器 的 元 素 。<br>
(1) 可 默 认 构 造 的 。 但 不 是 在 任 何 情 况 下 都 需 要 满 足 这 一 条 , 比 如 关 联 式 容 器 ,<br>
i 对 于 顺 序 容 器 , 除 非 在 初 始 化 的 时 候 需 要 插 入 默 认 构 造 的 若 干 个 对 象 , 或 者 调 用 容<br>
| 器 的 resize0、assign0、insert0等 函 数 的 菜 些 版 本 , 否 则 也 不 需 要 满 足 这 – 条 。<br>
(2)) 可 拷 贝 构 造 的 。<br>
(3) 可 拷 贝 赋 值 的 ( 但 也 不 是 在 任 何 情 况 下 都 需 要 )。<br>
这 几 条 条 对 基 本 数 据 类 型 及 不 含 指 针 成 员 和 引 用 成 员 的 类 型 都 是 适 用 的 。<br>
(4) 或 者 , 具 有 public的 、 采 用 拷 贝 的 方 式 显 式 定 义 的 拷 贝 构 造 函 数 、 拷 贝 赋<br>
, 值 函 数 和 析 构 函 数 。 这 一 条 适 用 于 含 有 指 针 成 员 或 引 用 成 员 的 对 象 ,<br>
但 模 拟 指 针 ( 例如 迭 代 器 ) 应 该 归 入 前 面 几 条 中</p>
<p>引 用 不 能 作 为 STL 容 噩 的 元 素 类 型 :<br>
第 一 , 引用 在创 建 时 必 须 初 始 化 为 一 个 具 体 的 对 氢 , 而 STL 容 器 不 能 满 尸 这 一 要 求 ;<br>
第 二 , 引 用 没 有 构 造 函 数 和 析 构 函 数 , 更 没 有 赋 值 语 义 .</p>
<h3 id="迭代器-v2"><a class="header-anchor" href="#迭代器-v2">¶</a>迭代器</h3>
<p>迭 代 器 是 为 了 降 低 容 器 和 泛 型 算 法 之 间 的 糖 合 性 而 设 计<br>
指 针 代 表 眠 正 的 内 存 地 址 , 即 对 象 在 内 存 中 的 存 储 位 置 ;<br>
而 迭 代 器 则 代 表 元 素 在 容 器 中 的 相 对 位 置<br>
( 当 道 历 容 命 的 时 候 , 关 联 式 容 器 的 元 素 也 就 具 有 了 “ 相 对 位 置 “)。</p>
<p>vector, 没 有 必 要 重 新 定 义 迭 代 器 类 型 , 其 元 素 ! 的 指 针 就 可 以 直 接 充 当 迭 代 器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T* iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> T* iterator;</span><br></pre></td></tr></table></figure>
<p>采 用 不 连 续 存 储 或 其 他 存 储 方 式 的 容 器 , 例 如 ist. deque. set. map 等 ,<br>
则 | 需 定 义 自 己 的 迭 代 器 类 (class), 一 般 情 况 下 它 们 是 对 元 素 指 针 的 封 装 , 即 模 拟 指 针</p>
<p>一 些 特 殊 容 器 如 <code>vector&lt;bool&gt;</code> 和 <code>bitset&lt;N&gt;</code> 等 ,</p>
<p>较 典 型 的 算 法 就 是 distance 和 advance。 这 方 面 的 知 识 涉 及 到 traits 技术<br>
使 用 <code>vector&lt;int&gt;::iterator</code>, 而不是<code>int*</code> 虽然它们是等价的’,</p>
<h4 id="迭代器失效"><a class="header-anchor" href="#迭代器失效">¶</a>迭代器失效</h4>
<p>迭 代 器 失 效 是 指 当 <strong>容 器 底 层 存 储 发 生 变 动</strong> 时 , 原 来 指 向 容 器 中 某 个 或 某 些 元 素 的 迭 代 器<br>
由 于 元 素 的 存 储 位 置 发 生 了 改 变 而 不 再 指 向 它 们 , 从 而 成 为 无 效 的 迭 代 器 。 |<br>
使 用 无 效 的 迭 代 器 就 像 使 用 无 效 的 指 针 ( 野 指 针 ) 一 样 危 险 。</p>
<p>引 起 容 器 存 储 的 变 动 呢<br>
主 要 有 : reserve(0、 resize(). push_back(), pop_back(). insert(). erase(). clear() 等 容 器 方 法<br>
和 一 些 泛 型 算 法 , 如 sort()、copy()、 replace()、remove()、unique(),<br>
以 及 集 合 操 作 ( 并 、 交 、 差 ) 算 法 等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">《</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ages; / 未 预 留 空 间</span><br><span class="line">ages.push_back(<span class="number">2</span>); / 引 起 内 存 重 分 配</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator p = ages.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> Ginti=<span class="number">0</span>;i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ages.push_back(<span class="number">5</span>); / 会 引 起 若 干 次 内 存 重 分 配 操 作</span><br><span class="line">&#125;</span><br><span class="line">. <span class="built_in">cout</span> &lt;&lt; “The first age :“&lt;&lt;*p &lt;&lt; <span class="built_in">endl</span>: /p 已 经 失 效 , 危 险 !</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator p = ages.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ages.push_back(<span class="number">5</span>); / 会 引 起 若 干 次 内 存 重 分 配 操 作</span><br><span class="line">&#125;</span><br><span class="line">p = ages.<span class="built_in">begin</span>(); / 重 新 获 取 迭 代 器</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The first age : “&lt;&lt; *p &lt;&lt; endl; 八 ok</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>容 量 是 为 了 减 少 那 些 使 用 连 续 空 间 ( 线 性 空 间 》 存 储 元 素 的 容 器 在 增 加 元 素 时<br>
重 新 分 配 内 存 的 次 数 的 一 种 机 制 , 即 当 增 加 元 素 且 剩 余 空 闲 空 间 不 足 时 ,<br>
按照 一 定 比 例 ( 通 常 是 原 来 容 量 的 2 或 1.5 倍 )<br>
<img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603075716.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我 们 可 以 从 <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;的 size0和 capacity0这 两 个</span><br><span class="line">成 员 函 数 的 实 现 上 看 出 容 器 所 辖 元 素 空 间 和 容 量 的 区 别 :</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> (start == <span class="number">0</span> ? <span class="number">0</span> : end_of_storage - start); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (start == (<span class="number">70</span>: finish - start); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> reserve(size_type n);</span><br></pre></td></tr></table></figure>
<p>(1)) 如 果 n 大 于 容 器 现 有 的 容 量 ( 即 capacity0),<br>
则 需 要 在 自 由 内 存 区 为 整 个 容 器 重 新 分 配 一 块 新 的 更 大 的 连 续 空 间 , 其 大 小 为 n * sizeof (T),<br>
然 后 将 容 器 内 所 有有 效 元 素 从 旧 位 置 全 部 拷 贝 到 新 位 置 ( 调 用 拷 贝 构 造 函 数 ),<br>
最 后 释 放 旧 位 置 的 所 有存 储 空 间 并 调 整 容 器 对 象 的 元 素 位 置 指 示 器<br>
( 就 是 让 那 三 个 指 针 指 向 新 内 存 区 的 相 应 位 置 )。<br>
也 就 是 说 , 如 果 请 求 容 量 比 原 有 容 量 大 的 话 , 结 果 是 容 器 的 冗 余 容 量 加 大<br>
(2) &lt;=n 什么都不做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> ¢ = <span class="number">0</span>; ¢ &lt; <span class="number">10</span>; c++)</span><br><span class="line">lipush_back (c);</span><br><span class="line">vi.reserve(li.<span class="built_in">size</span>());<span class="comment">// 预 留 空 间 , 但 是 并 没 有 改 变 容 器 的 大 小 , 预 留 空 间 未 初 始 化</span></span><br><span class="line"><span class="built_in">std</span>::copy (libegin0, liendO vi.<span class="built_in">begin</span>()); / 拷 贝赋 值</span><br><span class="line"><span class="built_in">std</span>::copy (vi-<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cerr</span>, <span class="string">"\t"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确使用方法</span></span><br><span class="line">vi.reserve (li.<span class="built_in">size</span>()); <span class="comment">// 预留 空 间 , 但 是 并 没 有 改 </span></span><br><span class="line"><span class="built_in">std</span>::copy(t.beginO, liend(), <span class="built_in">std</span>::back_inserter(vi));</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603081048.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="built_in">size</span> type n, <span class="keyword">const</span> T&amp; c = T())</span></span>;</span><br></pre></td></tr></table></figure>
<p>其 中 n 就 是 最 后 要 保 持 的 元 素 个 数 , 如 果 需 要 新 增 元 素 的 话 ,c 则 是 新 增 元 素 的 默 认<br>
壹 初 始 值 。 下 面 是 resize()的 实 现 策 略 。<br>
(1) 如 果 n 大 于 容 器 当 前 的 大 小 ( 即 size0), 则 在 容 器 的 末 尾 插 入 ( 追加 ) n<br>
size0个 初 值 为 c 的 元 素 , 如 果 不 指 定 初 值 , 则 用 元 素 类 型 的 默 认 构 造 函 数 来 初 始 化<br>
每一 个 新 元 素 〔 这 可 能 引 起 内 存 重 分 配 以 及 容 器 容 量 的 扩 张 )。<br>
(2) 如 果 n 小 于 容 器 当 前 的 大 小 , 则 从 容 器 的 末 尾 删 除 size 0 ~ n 个 元 素 ,<br>
但i <strong>不 释 放 元 素 本 身 的 内 存 空 间</strong>, 因 此 容 量 不 变 。<br>
(3) 否 则 , 什 么 也 不 做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">td::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; 。 止 ;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++)</span><br><span class="line">li.push_back (c);</span><br><span class="line">vi-resize(li.<span class="built_in">size</span>(); / 调 整 容 器 大 小</span><br><span class="line"><span class="built_in">std</span>::copy (li-<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), vi-<span class="built_in">begin</span>()); UMA</span><br><span class="line"><span class="built_in">std</span>::copy (vi-<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), <span class="built_in">std</span>::ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::<span class="built_in">cerr</span>, <span class="string">"\t"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603081829.png" alt=""></p>
<p>压 缩 容 器的 多 余 容 量 从 而 节 省 存 储 空 间</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; — vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++)</span><br><span class="line">vi.push_back (c);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(vi).swap(vi); W 构 造 一 个 临 时 对 象 , 然 后 与 之 交 换 元 素</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">17</span><span class="number">-7</span> 一 个 固 定 容 量 的 循 环 队 </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T <span class="comment">/* 元 素 类 型 */</span> , <span class="keyword">unsigned</span> <span class="keyword">int</span> N <span class="comment">/* 容 量 */</span> &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CyclicQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;</span><br><span class="line">CyclicQueue() : m_popPos(<span class="number">0</span>), m_count(<span class="number">0</span>) &#123;</span><br><span class="line">assert(N &gt; <span class="number">0</span>);</span><br><span class="line">m_beginPtr = (T*)(::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(T) * N)); / 分 配 原 始 空 间</span><br><span class="line">&#125; 。</span><br><span class="line">~CyclicQueue() &#123;</span><br><span class="line">_Clear(); <span class="comment">// this-&gt;_Clear(Q);</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="keyword">void</span>*)m_beginPtr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">CyclicQueue(<span class="keyword">const</span> CyclicQueue&lt;T, N&gt;&amp; copy) : m_popPos(<span class="number">0</span>), m_count(<span class="number">0</span>) &#123;</span><br><span class="line">assert(N &gt; <span class="number">0</span>);</span><br><span class="line">m_beginPtr = (T*)(<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(T) * N)); / 分 配 原 始 空 间</span><br><span class="line"><span class="keyword">size_t</span> copyPos = copy.m_popPos;</span><br><span class="line"><span class="keyword">for</span> (size_type idx = <span class="number">0</span>; idx &lt; copy.m_count; ++idx) 【</span><br><span class="line">_Copy(idx, copy.m_beginPtr[copyPos&#125;); <span class="comment">// this-&gt;_Copy0Q;</span></span><br><span class="line">++copyPos; copyPos %= N; ++m_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CyclicQueue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CyclicQueue&lt;T, N&gt;&amp; other) &#123;</span><br><span class="line">CyclicQueue&lt;T, N&gt; temp(other); W 调 用 拷 贝 构 造 函 数</span><br><span class="line">swap(temp); [ff <span class="keyword">this</span>-&gt;swapQ);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (m_count == <span class="number">0</span>); &#125;</span><br><span class="line"><span class="keyword">bool</span> isfulO <span class="keyword">const</span> &#123; <span class="keyword">return</span> (m_count == N); &#125;</span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">assert(m_count != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[m_popPos&#125;);</span><br><span class="line">&#125; .</span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">assert(m_count != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[m_popPos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">value_type <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">assert(m_count != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line"><span class="keyword">if</span> (pushPos== <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (*(m_beginPtr + N - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[pushPos - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">) <span class="function">value_type <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">assert(m_count &#123;= <span class="number">0</span>);</span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line"><span class="keyword">if</span> (pushPos == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (*(m_beginPtr + N - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[pushPos - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">; <span class="keyword">bool</span> push(const_reference data = TO) &#123;</span><br><span class="line">| <span class="keyword">if</span> (m_count &lt;N) t / 不 满 !</span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line">i _Copy(pushPos, data); /! <span class="keyword">this</span>-&gt;_CopyQ;</span><br><span class="line">++m_count;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">) <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(reference data)</span> </span>&#123;</span><br><span class="line">| <span class="keyword">if</span> (m_count &gt; <span class="number">0</span>) &#123; 丫 不 宇 !</span><br><span class="line">data = m_beginPtr[m_popPos]; /f <span class="keyword">operator</span>=</span><br><span class="line">彗 _Destroy(m_popPos); <span class="comment">// this-&gt;_Destroy(Q);</span></span><br><span class="line">--m_count; ++m_popPos; m_popPos %= N; / 新 的 pop 位 置</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;_Clear(); &#125; / <span class="keyword">this</span>-&gt;_Clear();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(CyclicQueue&lt;T, N&gt;&amp; other)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::swap(m_beginPtr, other.m_beginPtr);</span><br><span class="line"><span class="built_in">std</span>::swap(m_popPos, other.m_popPos);</span><br><span class="line"><span class="built_in">std</span>::swap(m_count, other.m_count);i|</span><br><span class="line">i</span><br><span class="line">' &#125;</span><br><span class="line">i</span><br><span class="line">ii <span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; m_count &gt; <span class="number">0</span>; --m_count) &#123;</span><br><span class="line">_Destroy(m_popPos); H <span class="keyword">this</span>-&gt;_Destroy();</span><br><span class="line">| ++m_popPos; m_popPos %= N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_popPos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Destroy(sizetype idx) &#123;</span><br><span class="line">assert(idx &lt; NJ;</span><br><span class="line">T *pTemp = (m_beginPtr + idx);</span><br><span class="line">pTemp-&gt;~TQ; W 调 用 析 构 函 数 销 毁 元 素 对 象</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _Copy(size_type idx, const_reference data) &#123;</span><br><span class="line">assert(idx &lt; N);</span><br><span class="line">T *pTemp = (m_beginPtr + idx);</span><br><span class="line"><span class="keyword">new</span> ((<span class="keyword">void</span>*)pTemp) T(data); <span class="comment">// 调 用 placement new 和 拷 贝 构 造 函 数 拷 贝 对 象</span></span><br><span class="line">| &#125;|</span><br><span class="line">| value_type *m_beginPtr; / 队 列 存 储 空 间 起 始 位 置</span><br><span class="line">size_type m_popPos; / 下 次 pop 位 置</span><br><span class="line">| size_type m_count; / 有 效 元 紫 个 数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>尽 量 不 要 在 道 历 容 器 的 过 程 中 义 容 器 进 行 插 入 元 素 、 删除 元 素 等 修 改 擎作 ,</strong><br>
这 和 不 要 在 for 循 环 中 修 改 计 数 器 是 一 个 道 理 , 特 别 是 连 续 存 储 的 容器 中 。<br>
因 为 这 些 操 作 会 使 一 些 追 代 器 失 效 , 特 别 是 当 前 选 代 器 , 这 在 效果 上 等 价 于 修 改 了 循 环 计 数 器 。<br>
更 进 一 步 的 原 因 是 下 一 次 迭 代 操 作 , 即++iterator 会 使 用 本 次 选 代 操 作 的 选 代 器 ,<br>
而 当 前 迭 代 器 可 能 已 经 失 效</p>
<p>虽然 有 些 容 器 如 list, 修 改 操 作 只 会 使 当 前 选 代 器 失 效 , 即 并 不 会 引 起 存储 空 间 重 分 配 ,<br>
所 以 可 以 在 邋 历 的 过 程 中 正 确 地 删 除 当 前 元 素 ( 这 里 面有一 个 技 巧 ),<br>
但 是 也 最 好 不 要 这 样 做 , 否 则 可 能 存 在 重 大 隐 惠 . 参 见 list等 的 remove(). remove_if() 成 员 函 数 的 实 现</p>
<h3 id="存储分配器"><a class="header-anchor" href="#存储分配器">¶</a>存储分配器</h3>
<p>allocator类 是 一 个 模 板 , 作 为 容 器 类 模 板 的 一 个 policy 参 数 , 它 不 仅 与 将 要 为 之<br>
分 配 空 间 的 数 据 对 象 的 类 型 无 关 , 并 且 为 动 态 内 存 的 分 配 和 释 放 提 供 了 面 向 对 象 的<br>
接 口 。 它 是 对 new 运 算 符 的 更 高 层 次 的 抽 象 , 即 隐 藏 了 底 层 的 内 存 模 式 〔 段 内 存 、<br>
! 共享 内 存 、 分 布 式 内 存 等 ), 封 装 了 动 态 内 存 分 配 和 释 放 操 作 , 隐 藏 了 指 针 本 身 的 大<br>
| 小 、 存 储 空 间 重 分 配 模 型 及 内 存 页 大 小 等 细 节 , 提 供 了 更 好 的 可 移 植 性 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">17</span><span class="number">-8</span>  COM 环 境 下 STL 容 器 的 allocator 实 </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">STLCOMAllocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line"><span class="keyword">typedef</span> _Ty* pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> _Ty* const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> _Ty&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> _Ty&amp; const_reference;</span><br><span class="line"><span class="function">pointer <span class="title">address</span><span class="params">(reference ref)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (&amp;ref); &#125;</span><br><span class="line"><span class="function">const_pointer <span class="title">address</span><span class="params">(const_reference ref)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (&amp;ref); &#125;</span><br><span class="line"><span class="function">_Ty* <span class="title">allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/* no use */</span> )</span></span></span><br><span class="line">皇 &#123; return (pointer)(::CoTaskMemAlloc(n * sizeof(_Ty))); &#125; // aligned!</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, size_type <span class="comment">/* no use */</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123; ::CoTaskMemFree(p); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="keyword">const</span> Ty&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="keyword">new</span> ((<span class="keyword">void</span>*)p)_Ty(v); <span class="comment">// placement new &amp; copy constructor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) p-&gt;~_TyQ; <span class="comment">// destructor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">size_type sz = (size_type)(<span class="number">-1</span>) / <span class="keyword">sizeof</span>(_ Ty);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> &lt; sz? sz: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty, <span class="keyword">typename</span> _U&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">bool</span> __stdcall <span class="keyword">operator</span> ==(<span class="keyword">const</span> STLCOMAllocator&lt;_Ty&gt;&amp;,</span><br><span class="line"><span class="keyword">const</span> STLCOMAllocator&lt;_U&gt;&amp;)</span><br><span class="line">&#123; <span class="keyword">return</span> (<span class="literal">true</span>); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty, <span class="keyword">typename</span> _U&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">bool</span> __stdcall <span class="keyword">operator</span> !=(<span class="keyword">const</span> STLCOMAIlocator&lt;_Ty&gt;&amp;,</span><br><span class="line"><span class="keyword">const</span> STLCOMAIlocator&lt;_U&gt;&amp;)</span><br><span class="line">&#123; <span class="keyword">return</span> (<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="适配器-容器适配器-stack-deque-list"><a class="header-anchor" href="#适配器-容器适配器-stack-deque-list">¶</a>适配器 容器适配器 stack deque list</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k+<span class="number">4</span>) &#123;</span><br><span class="line">li.push_back(k);</span><br><span class="line">&#125;</span><br><span class="line">copy(li.<span class="built_in">begin</span>(), li.endQ, ostream _iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>, <span class="string">" "</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span> ;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eos, isiter(<span class="built_in">cin</span>);</span><br><span class="line">copy(isiter, eos, back_inserter(li));</span><br><span class="line">copy(li.<span class="built_in">begin</span>(),li.<span class="built_in">end</span>(), ostream_iterator&lt;<span class="keyword">int</span>&gt;(<span class="built_in">cout</span>,<span class="string">""</span>));</span><br></pre></td></tr></table></figure>
<h3 id="泛型算法-v2"><a class="header-anchor" href="#泛型算法-v2">¶</a>泛型算法</h3>
<p>STL 提 供 的 泛 型 算 法 主 要 有 如 下 几 种 ;</p>
<blockquote>
<p>“ 查 找 算 法 , 如 find0、search0、binary search()、find_if0等 。<br>
今 “ 排 序 算 法 , 如 sort)、merge0等 。<br>
从 “ 数 学 计 算 , 如 accumulate0、inner product0、partial sum0 等 。</p>
</blockquote>
<ul>
<li>“ 集合 运 算 , 如 set_union0、set_intersection0、includes0等 。</li>
<li>“容器 管 理 , 如 copy0、replace0、transform0、remove()、for each() 等 。</li>
</ul>
<blockquote>
<p>“ 统 计 运 算 , 如 max(0O、min0、count0、max_element0等 。<br>
今 “ 堆 管 理 , 如 make_heap()、push_heap0、pop_ heap(). sort_heap().<br>
“ 比 较 运 算 , 如 equal0等</p>
</blockquote>
<p>泛 型 算 法 一 般 接 受 下 列 参 数 类 型 的 一 种 或 几 种<br>
“ 迭 代 器 , 标 示 容 器 或 区 间 的 范 围 , 以值 传 递 。<br>
从 “ 谓 词 , 返 回 bool 值 的 函 数 对 象 , 指 定 算 法 的 操 作 方 式 , 例 如 find_if0的 第 三<br>
个 参 数 。<br>
从 函 数 对 象 , 用 户 指 定 要 做 的 操 作 , 例 如 for_ each(0)的 第 三 个 参 数 。<br>
今 “ 容器 元 素 , 用 户 指 定 的 基 准 对 象 , 例 如 find0的 第 三 个 参 数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Template&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> Outputlterator&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="function">Outputlterator <span class="title">copy</span><span class="params">(Inputlterator first, InputIterator last, Outputlterator oi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; first != last; ++first, ++oi)</span><br><span class="line">	*oi = *first;</span><br><span class="line">	<span class="keyword">return</span> Oi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; i; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c&lt; <span class="number">10</span>; c++) li.push_back(c);</span><br><span class="line">vi.resize(li.<span class="built_in">size</span>());</span><br><span class="line">copy(libeginO, liendO, vi.<span class="built_in">begin</span>()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; i; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c&lt; <span class="number">10</span>; c++) li.push_back(c);</span><br><span class="line">/ 拷 贝 链 表 元 素 到 vi 中 , 使 用 插 入 迭 代 器</span><br><span class="line">copy(libegin(, li.endQ), back_inserter(vi)); / 调 用 vi.push_back()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>侃 多 泛 型 算 法 总 是 假 定 容 器 的 元 素 类 型 定 义 了 operator-(、operator–0、 operatorl=()、operator&lt;() 或 operator&gt;() 等 函 数 , 因 此 你 有 义 务 为 你 的 家 器 元 素 类 型 定 义 它 们 , 否 则 泛 型 算 法 将 采 用 元 素 类 型 的 默 认 语 义 或 者 报 错。</p>
<p>在 应 用 编 程 时 要 选 用 最 合 适 的 算法<br>
,find0 算 法 的 复 杂 度 为 O(, 而 binary seareh0 算 法 的 复 杂 度 为$O(log{2}N)$当 容 器 中 的 元 素 有 序 时 , 当 然 应 选 用 binary seareh0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">17</span><span class="number">-15</span> 基 于 STL 框 架 实 现 的 “ 折 半 “ 查找 算法</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">RandomAccessIterator <span class="title">binary_search</span><span class="params">(RandomAccesslterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">RandomAccesslterator last,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> T&amp; value)</span></span></span><br><span class="line">RandomAccesslterator mid, not_found = last;</span><br><span class="line"><span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">mid = first + (last - frst) / <span class="number">2</span>:; / 注 意 : 不是 (first + last) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>(L(value &lt; *mid) &amp;&amp; !(*mid &lt; value))</span><br><span class="line"><span class="keyword">return</span> mid; /! 调 用 T::<span class="keyword">operator</span>&lt;()</span><br><span class="line"><span class="keyword">if</span> (value &lt; *mid)</span><br><span class="line">last = mid; <span class="comment">// 调 用 T::operator&lt;()</span></span><br><span class="line"><span class="keyword">else</span> first = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> not_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些特殊容器"><a class="header-anchor" href="#一些特殊容器">¶</a>一些特殊容器</h3>
<h3 id="string-类"><a class="header-anchor" href="#string-类">¶</a>string 类</h3>
<h3 id="bitset-并非set"><a class="header-anchor" href="#bitset-并非set">¶</a>bitset 并非set</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> Length&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bitset</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">reference</span>&#123;</span> ... &#125;; / 可 以 自 动 转 换 为 <span class="keyword">bool</span> 变 量</span><br><span class="line"><span class="comment">// constructors...</span></span><br><span class="line">Hf accessors...</span><br><span class="line"><span class="comment">// rautators...</span></span><br><span class="line"><span class="comment">// convertors...</span></span><br><span class="line"><span class="comment">// statistics...</span></span><br><span class="line"><span class="comment">// test...</span></span><br><span class="line">I &amp;=, |=, *=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;, &lt;&lt;, ==, !=, ~ overloading...</span><br><span class="line">/ &lt;&lt;(output), &gt;&gt;(input), &amp;, |, ^ <span class="keyword">friend</span> overloading...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">WORD BITS = <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) * <span class="number">8</span>, / WORD 的 <span class="built_in">bit</span> 数</span><br><span class="line">N_WORD= ( Length== <span class="number">0</span> ? <span class="number">0</span> : (Length - <span class="number">1</span>) /,WORD_BITS )</span><br><span class="line"><span class="comment">// Length 个 bit 折 合 多 少 个 WORD</span></span><br><span class="line">出</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">array</span>[N_WORD + <span class="number">1</span>]; ABBA ( 不 能 定 义 长 度 为 <span class="number">0</span> 的 数 组 )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603090456.png" alt=""></p>
<h3 id="vector-bool"><a class="header-anchor" href="#vector-bool">¶</a><code>vector&lt;bool&gt;</code></h3>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603091045.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; BoolVector; <span class="comment">// vector&lt;bool&gt;的 具 体 名 字 与 STL 实现 有 关</span></span><br><span class="line">BoolVector bvect;</span><br><span class="line">bvect.reserve(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">bvect.insert(bvect.<span class="built_in">end</span>(), <span class="literal">true</span>);</span><br><span class="line">bvect.insert(bvect.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BoolVector::iterator first = bvect.<span class="built_in">begin</span>(),</span><br><span class="line">last = bvect.<span class="built_in">end</span>(); first != last; ++first) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bvect.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">bvect.front(). flipQ;</span><br><span class="line">bvect.back().flipQ;</span><br><span class="line">bvect.flipQ;</span><br><span class="line">bvect.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="空容器"><a class="header-anchor" href="#空容器">¶</a>空容器</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li; / 空 容 器</span><br><span class="line">li.pop_backQ; <span class="comment">// runtime error!</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line">(!li.empty()) li.erase(li.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 例 <span class="number">17</span><span class="number">-20</span>。 示 例 <span class="number">17</span><span class="number">-20</span> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt; / 顺 序 容 器 </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt; / 联 合 容 器</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; using namespace std; </span></span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; temp1;</span><br><span class="line">   temp] .insert(temp1.<span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; li; W 空 容 器</span><br><span class="line">liinsertdisend0, <span class="number">10</span>); / 创 建 新 对 象</span><br><span class="line">li.insert(li.endQ, <span class="number">10</span>); / 创 建 新 对 象</span><br><span class="line">Iierase(temp1l.begin0O); “ 丫 runtime error! 虫 然 li 中 也 有 值 为 <span class="number">10</span> 的 <span class="keyword">int</span> 元 素</span><br><span class="line">/ 但 是 temp1.begin0指 向 的 元 素 对 象 并 不 属 于 li 所 有</span><br><span class="line">lierase(li-<span class="built_in">begin</span>(Q)); ok! libegin0指 向 的 对 象 为 ii 所 有</span><br><span class="line">| lierase(*p); W compiling error! 没 有 定 义 这 样 的 方 法 , 对象 *p 不</span><br><span class="line">W 属 于 i 所 有 。 不 能 以 元 素 的 值 来 判 断 其 是 否 属 于 一</span><br><span class="line">W 个 顺 序 容 器 , 因 为 顺 序 容 器 可 以 同 时 存 储 值 完 全 相 同</span><br><span class="line">W 的 多 个 对 象 ; 否 则 容 器 将 不 知 道 该 删 除 哪 一 个 元 素 了</span><br><span class="line"><span class="number">1</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; temp2;</span><br><span class="line">| temp2.insert(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; si; / 空容 器</span><br><span class="line">siinsert(<span class="number">10</span>); / si 包 含 一 个 值 为 <span class="number">10</span> 的元 素</span><br><span class="line">siinsert(si.<span class="built_in">end</span>(<span class="number">0</span>), <span class="number">20</span>);</span><br><span class="line">siinsert(sisend(<span class="number">0</span>), <span class="number">20</span>); 丫 忽 略 !</span><br><span class="line">si.erase(temp2.beginQ); —_<span class="comment">// runtime error! temp2.begin0指 向 的 对 参 不 属 于 si 所 有</span></span><br><span class="line">si.erase(*p); (OK! 从 si 中 删 除 值 等 于 *p 的元 素</span><br><span class="line">si.erase(si.<span class="built_in">begin</span>()); OK! sitbegin0 指 向 的 对 象 为 si 所 有</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除 了 上 面 这 些 特 殊 容 器 外 , 还 有 一 些 专 用 于 数 学 运 算 的 容 器 、 算 法 和 类 型 ,<br>
如 valarray、 complex 等 , 分 别 定 义 在 头 文 件 <code>&lt;valarray&gt;和 &lt;complex&gt;</code> 中 ,<br>
头 文 件 <code>&lt;numeric&gt;</code> 中 定 义 了 用 于 向 量 计 算 的 算 法</p>
<p>往 容 器 中 插 入 元 素 时 , 若 元 素 在 容 器 中 的 顺 序 无 关 紧 要 , 请 尽 量 加 在 最<br>
后 面 。 若 经 常 需 要 在 序 列 容 器 的 开 头 或 中 间 增 加 或 删 除 元 素 时 , 应选 用<br>
list.</p>
<p>当 容 器 作 为 参 数 被 传 递 时 , 请 采 用 引 用 传 递 方 式 。 否 则 将 调 用 容 器 的 拷<br>
贝构 造 函 数 , 其 开 销 是 难 以 想 象 的</p>
<p>当 元 素 的 有 序 比 搜 索 速 度 更 重 要 时 , 应 选 用 set. multiset.map或 multimap。<br>
否 则 , 选 用 hash_set、hash_multiset、hash_map 或 hash_multimap。</p>
<p><img src="git-repos/gitee/blog/source/_posts/C++/Pasted%20image%2020230603100246.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert( (strDest != <span class="literal">NULL</span>) &amp;&amp; (srtSrc != <span class="literal">NULL</span>) );</span><br><span class="line">	<span class="keyword">char</span>* address = strDest;</span><br><span class="line">	<span class="keyword">while</span> ( (*strDest++ = *strSrc++) != <span class="string">'\0'</span> );</span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">""</span>); <span class="comment">//智 通 构 造 函 数</span></span><br><span class="line">	<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other);  <span class="comment">// 拷 贝 构 造 函 数</span></span><br><span class="line">	~ <span class="keyword">String</span>(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">String</span>&amp; operate =(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//String 的 普 通 构 造 函 数</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str) / <span class="number">6</span> 分</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(str == <span class="literal">NULL</span>)</span><br><span class="line">	&#123; </span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的 析 构 函 数</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷 贝 构 造 函 数</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值 函 数</span></span><br><span class="line"><span class="keyword">String</span> &amp; <span class="keyword">String</span>::operate =(<span class="keyword">const</span> <span class="keyword">String</span> &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> *temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(temp, other.m_data);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">delete</span> [] m_data;</span><br><span class="line">		m_data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2023/06/04/C++11、C++14、C++17、C++20新特性总结（5万字详解）/" data-toggle="tooltip" data-placement="top" title="C++11、C++14、C++17、C++20新特性总结（5万字详解）">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2021/01/06/健身笔记/" data-toggle="tooltip" data-placement="top" title="健身笔记">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://www.roading.org" target="_blank">Adoo&#39;s blog</a></li>
                    
                        <li><a href="https://blog.csdn.net/chosen0ne/" target="_blank">娄振林专栏</a></li>
                    
                        <li><a href="https://www.cnblogs.com/miloyip/" target="_blank">Milo的游戏开发</a></li>
                    
                        <li><a href="https://www.cnblogs.com/zhaoyl/" target="_blank">Just Love U</a></li>
                    
                        <li><a href="https://www.cnblogs.com/sniperHW/" target="_blank">sniperHW</a></li>
                    
                        <li><a href="http://www.cppblog.com/converse/" target="_blank">那谁的技术博客</a></li>
                    
                        <li><a href="http://www.cppblog.com/Solstice/" target="_blank">陈硕的Blog</a></li>
                    
                        <li><a href="https://www.cnblogs.com/learnhow/p/9420404.html#4035973" target="_blank">30分钟带你了解Docker</a></li>
                    
                        <li><a href="https://leftnoteasy.cnblogs.com/" target="_blank">LeftNotEasy - Wangda Tan</a></li>
                    
                        <li><a href="https://blog.codingnow.com/" target="_blank">云风的 BLOG</a></li>
                    
                        <li><a href="https://iyuan.iteye.com/blog/search?page=4&amp;query=ZeroMQ%E5%88%9D%E4%BD%93%E9%AA%8C" target="_blank">zero MQ</a></li>
                    
                        <li><a href="https://levblanc.github.io/" target="_blank">levblanc blog</a></li>
                    
                        <li><a href="https://blog.zhangruipeng.me/hexo-theme-icarus/" target="_blank">zhangruipeng blog</a></li>
                    
                        <li><a href="https://v-vincen.life/" target="_blank">v-vincen blog</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: '∞'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<script>
    /**/
    function setClipboardText(event){
        event.preventDefault();//阻止元素发生默认的行为（例如，当点击提交按钮时阻止对表单的提交）。
        var node = document.createElement('div');
        //对documentfragment不熟，不知道怎么获取里面的内容，用了一个比较笨的方式
        node.appendChild(window.getSelection().getRangeAt(0).cloneContents());
        //getRangeAt(0)返回对基于零的数字索引与传递参数匹配的选择对象中的范围的引用。对于连续选择，参数应为零。
        var htmlData = '<div>'
            + node.innerHTML
            + '<br /><br />著作权归作者所有。<br />'
            + '商业转载请联系作者获得授权，非商业转载请注明出处。<br />'
            + '作者：Zirpon Cheung <br />链接：'
            + location.href
            + '<br />来源：dianfanbao.ltd<br /><br />'
            + '</div>';
        var textData = window.getSelection().getRangeAt(0)
            + '\n\n著作权归作者所有。\n'
            + '商业转载请联系作者获得授权，非商业转载请注明出处。\n'
            + '作者：Zirpon Cheung\n'
            + '链接：'
            + location.href
            + '来源：dianfanbao.ltd\n\n';
        if(event.clipboardData){
            event.clipboardData.setData("text/html", htmlData);
            //setData(剪贴板格式, 数据) 给剪贴板赋予指定格式的数据。返回 true 表示操作成功。
            event.clipboardData.setData("text/plain",textData);
        }
        else if(window.clipboardData){ //window.clipboardData的作用是在页面上将需要的东西复制到剪贴板上，提供了对于预定义的剪贴板格式的访问，以便在编辑操作中使用。
            return window.clipboardData.setData("text", textData);
        }
    };
 
    document.addEventListener('copy',function(e){
        setClipboardText(e);
    });
</script>



<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="https://zirpon.github.io/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>



<!--
<!DOCTYPE html>
<html lang="en">
<body class="">
<div>
<img src="https://champon.gitee.io/blog/img/header_img/RomanTheatre_ZH-CN9417897135_1920x1080.jpg" 
    width='64px' height='48px'>
</div>
</body>
</html>
-->

	<!-- Footer (contains ThemeColor、viewer) -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/monkeyzhang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/Zirpon">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Zirpon Cheung 2024 
                    <br>
                    Theme by <a href="http://beantech.org/" target="_blank" rel="noopener">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="https://zirpon.github.io">Zirpon</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=Zirpon&repo=hexo-theme-zirpon&type=star&count=true" >
                    </iframe>

                    <br>
                </p>
                <br>
                <!-- cnzz Tongji -->
                
            </div>
        </div>
    </div>
</footer>

<!-- cnzz Tongji -->


<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- totop(rocket) -->
<script type="text/javascript" async="true" src="https://zirpon.github.io/js/totop.js?v=1.0.0"></script>

<!-- Busuanzi JavaScript -->
<script type="text/javascript" async="true" src="/js/busuanzi.pure.mini.js"></script>


    <!-- ThemeColor start -->
    <script type="text/javascript" src="https://zirpon.github.io/js/themecolor.js"></script>
    <!-- ThemeColor end -->



    <!-- viewer start -->
    <!-- viewer start (Picture preview) -->
    <script type="text/javascript" src="/js/viewer/viewer.min.js"></script>
    <script type="text/javascript" src="/js/viewer/pic-viewer.js"></script>
    <!-- viewer end -->


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }

    // fastClick.js
    async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav)
        FastClick.attach($nav);
        }
    )
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->





    <!-- Search -->
	
        <div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  <script src="/js/ziploader.js"></script>
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;

            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('-1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


    

    <a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="https://zirpon.github.io/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="https://zirpon.github.io/js/toc.js?v=1.0.0" async=""></script>
    <!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
